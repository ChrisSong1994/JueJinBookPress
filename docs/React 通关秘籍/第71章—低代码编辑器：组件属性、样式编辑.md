# 第71章—低代码编辑器：组件属性、样式编辑

﻿这节我们来做属性编辑的功能。

在 [amis](https://aisuda.github.io/amis-editor-demo/#/edit/0) 中，选中不同组件会在右边展示对应的属性：

![](./images/b5449475f881fab78cd24a0acc229f71.gif )

编辑属性，会修改 json 中的内容：

![](./images/acba492b97b261d47035f087540ba07f.webp )

我们只要在选中组件的时候，在右边展示组件对应属性的表单就行了。

不同组件的属性是不同的，这部分明显是在 componentConfig 里配置。

![](./images/5536489f1fe61567b39e4839b0626953.webp )

```javascript
export interface ComponentSetter {
    name: string;
    label: string;
    type: string;
    [key: string]: any;
}

export interface ComponentConfig {
    name: string;
    defaultProps: Record<string, any>,
    desc: string;
    setter?: ComponentSetter[]
    component: any
}
```

先给 Button 加一下：

![](./images/bcf816817281982951c48e37d0db58b2.webp )

用 setter 属性来保存属性表单的配置，这里有 type、text 两个属性，就是两个表单项。

```javascript
{
  name: 'type',
  label: '按钮类型',
  type: 'select',
  options: [
    {label: '主按钮', value: 'primary'},
    {label: '次按钮', value: 'default'},
  ],
},
{
  name: 'text',
  label: '文本',
  type: 'input',
}
```
name 是字段名、label 是前面的文案，type 是表单类型。

select 类型的表单多一个 options 来配置选项。

在 Setting 组件里取出 curComponentId 对应的属性，渲染成表单就好了：

![](./images/4423e9893960eceaa0531efa4f436a47.webp )

其实 Setting 部分不只是设置属性，还可以设置样式、绑定事件：

![](./images/09aae981e3dfe86eb7c39b5ed9387b9c.webp )

![](./images/9a3b47eb332752f3002ad494931163e3.webp )

我们先预留出位置来：

components/Setting/index.tsx
```javascript
import { Segmented } from 'antd';
import { useState } from 'react';
import { useComponetsStore } from '../../stores/components';
import { ComponentAttr } from './ComponentAttr';
import { ComponentEvent } from './ComponentEvent';
import { ComponentStyle } from './ComponentStyle';

export function Setting() {

    const { curComponentId } = useComponetsStore();

    const [key, setKey] = useState<string>('属性');

    if (!curComponentId) return null;
  
    return <div >
        <Segmented value={key} onChange={setKey} block options={['属性', '样式', '事件']} />
        <div>
            {
                key === '属性' && <ComponentAttr />
            }
            {
                key === '样式' && <ComponentStyle />
            }
            {
                key === '事件' && <ComponentEvent />
            }
        </div>
    </div>
}
```
components/Setting/ComponentAttr.tsx
```javascript
export function ComponentAttr() {
    return <div>ComponentAttr</div>
}
```
components/Setting/ComponentStyle.tsx
```javascript
export function ComponentStyle() {
    return <div>ComponentStyle</div>
}
```
components/Setting/ComponentEvent.tsx
```javascript
export function ComponentEvent() {
    return <div>ComponentEvent</div>
}
```
如果 curComponentId 为 null，也就是没有选中的组件，就 return null。

用 antd 的 [Segmentd 组件](https://ant-design.antgroup.com/components/segmented-cn)来做上面的 tab。

然后分别用 ComponentAttr、ComponentStyle、ComponentEvent 组件渲染组件的属性、样式、事件。

![](./images/602ca417f011803a0a229dea8da714fe.gif )

没啥问题。

然后来写 ComponentAttr 组件：

```javascript
import { Form, Input, Select } from 'antd';
import { useEffect } from 'react';
import { ComponentConfig, ComponentSetter, useComponentConfigStore } from '../../stores/component-config';
import { useComponetsStore } from '../../stores/components';

export function ComponentAttr() {

  const [form] = Form.useForm();

  const { curComponentId, curComponent, updateComponentProps } = useComponetsStore();
  const { componentConfig } = useComponentConfigStore();

  useEffect(() => {
    const data = form.getFieldsValue();
    form.setFieldsValue({...data, ...curComponent?.props});
  }, [curComponent])

  if (!curComponentId || !curComponent) return null;
  
  function renderFormElememt(setting: ComponentSetter) {
    const { type, options } = setting;
  
    if (type === 'select') {
      return <Select options={options} />
    } else if (type === 'input') {
      return <Input />
    }
  }

  function valueChange(changeValues: ComponentConfig) {
    if (curComponentId) {
      updateComponentProps(curComponentId, changeValues);
    }
  }

  return (
    <Form
      form={form}
      onValuesChange={valueChange}
      labelCol={{ span: 8 }}
      wrapperCol={{ span: 14 }}
    >
      <Form.Item label="组件id">
        <Input value={curComponent.id} disabled />
      </Form.Item>
      <Form.Item label="组件名称">
        <Input value={curComponent.name} disabled />
      </Form.Item>
      <Form.Item label="组件描述">
        <Input value={curComponent.desc} disabled/>
      </Form.Item>
      {
        componentConfig[curComponent.name]?.setter?.map(setter => (
          <Form.Item key={setter.name} name={setter.name} label={setter.label}>
            {renderFormElememt(setter)}
          </Form.Item>
        ))
      }
    </Form>
  )
}
```
首先，如果 curComponentId 为 null，也就是没有选中组件的时候，返回 null

![](./images/89db29dde09a8072562b05e03b299de0.webp )

当 curComponent 变化的时候，把 props 设置到表单用于回显数据：

![](./images/05575d2b1963f757a7394b2cefb79301.webp )

当表单 value 变化的时候，同步到 store：

![](./images/679ef9c0353440f88f1f669eb8a033c1.webp )

下面就是表单项目，分别渲染 id、name、desc 属性，还有组件对应的 setter：

![](./images/13714b97965f6c0de54e9e462c5f558e.webp )

id、name、desc 都不可修改，设置 disabled。

setter 要根据类型来渲染不同的表单组件，比如 Select、Input。

测试下：

![](./images/1e026b5bf22d6b6d20ae0e40e4b9c01b.gif )

可以看到，当切换到 Page、Container、Button 组件的时候，展示了对应属性的表单。

现在按钮类型、文本都是可以修改的，画布区会同步变化：

![](./images/332aafafbb39042c79d2f1deedf36593.gif )

没啥问题。

当然，现在我们组件还不多，之后组件多了以后，表单项类型会更多。

到时候扩展这里就可以了：

![](./images/21f9d10dbce216feeb92bfb0bd119909.webp )

扩展更多的 setter 类型，支持 radio、checkbox 等表单项。

还有，现在这里贴的比较紧，我们加个 padding：

![](./images/664d14faee8280eba88e6ac5b15a1f44.webp )

![](./images/978e3e4535a0d97644bb311a5b275245.webp )

![](./images/7483d3c2917a1adc84ee0f92f5e8f300.webp )

好多了。

然后我们再来写下样式的编辑：

在 components 的 store 添加 styles 和更新 styles 的方法：

![](./images/5f5c58d96b5d4224f30fad8b56b105bd.webp )

![](./images/ea3f0e178dbc5890232e7631fd5e9cfa.webp )

```javascript
updateComponentStyles: (componentId: number, styles: CSSProperties) => void;
```

```javascript
updateComponentStyles: (componentId, styles) =>
    set((state) => {
      const component = getComponentById(componentId, state.components);
      if (component) {
        component.styles = {...component.styles, ...styles};

        return {components: [...state.components]};
      }

      return {components: [...state.components]};
    })   
```

在渲染组件的时候传进去：

![](./images/6501101db864eea93bce4b76058e399b.webp )

给渲染的组件参数加一个 styles 参数：

![](./images/493659036ca9a338c114b3387a8f7c95.webp )

把 styles 渲染出来：

Button 组件：

![](./images/9303d5f7866cd6321dc8f389616152e7.webp )

Container 组件：

![](./images/89d0b5d5cb09baca0d24c60a1f50cfef.webp )

Page 组件：

![](./images/83e92f3684165024d5d4ea2d9b75375c.webp )

然后我们在 addComponent 的时候加上个 styles 试试：

![](./images/fa875cf3799f8bdf0eda21c340de04ea.webp )

![](./images/7a2f971983fb2a2ea89c3d9fbdf2caa7.gif )

生效了。

这样我们就把 styles 保存在了 json 里，并且渲染的时候设置到了组件。

然后做下 styles 的编辑就好了。

amis 的样式编辑上面是一些 css 的样式可以选择，下面还可以直接写 css：

![](./images/5e4fc12e8049c52712849940440a5613.gif )

而且每个组件配置的样式都不同：

![](./images/3f92cfd5615669026f8b19cbb3e8d279.gif )

这个也和组件 props 一样，需要在 componentConfig 配下表单项：

![](./images/43c13011b93137c858ed5035dc876ae3.webp )

![](./images/e6ee55e50b1f7c1af9496f338eb032e8.webp )
```javascript
stylesSetter?: ComponentSetter[]
```
```javascript
stylesSetter: [
    {
        name: 'width',
        label: '宽度',
        type: 'inputNumber',
    },
    {
        name: 'height',
        label: '高度',
        type: 'inputNumber',
    }
],
```
然后在 ComponentStyle 里面渲染下：

```javascript
import { Form, Input, InputNumber, Select } from 'antd';
import { CSSProperties, useEffect } from 'react';
import { ComponentConfig, ComponentSetter, useComponentConfigStore } from '../../stores/component-config';
import { useComponetsStore } from '../../stores/components';

export function ComponentStyle() {

  const [form] = Form.useForm();

  const { curComponentId, curComponent, updateComponentStyles } = useComponetsStore();
  const { componentConfig } = useComponentConfigStore();

  useEffect(() => {
    const data = form.getFieldsValue();
    form.setFieldsValue({...data, ...curComponent?.styles});
  }, [curComponent])

  if (!curComponentId || !curComponent) return null;

  function renderFormElememt(setting: ComponentSetter) {
    const { type, options } = setting;
  
    if (type === 'select') {
      return <Select options={options} />
    } else if (type === 'input') {
      return <Input />
    } else if (type === 'inputNumber') {
        return <InputNumber />
    }
  }

  function valueChange(changeValues: CSSProperties) {
    if (curComponentId) {
        updateComponentStyles(curComponentId, changeValues);
    }
  }

  return (
    <Form
      form={form}
      onValuesChange={valueChange}
      labelCol={{ span: 8 }}
      wrapperCol={{ span: 14 }}
    >
      {
        componentConfig[curComponent.name]?.stylesSetter?.map(setter => (
          <Form.Item key={setter.name} name={setter.name} label={setter.label}>
            {renderFormElememt(setter)}
          </Form.Item>
        ))
      }
    </Form>
  )
}
```
和 ComponentAttr 没啥区别，就是把更新方法换成 updateComponentStyles

测试下：

![](./images/7a9ca83e09d52b24dd8f556dcaa43f8a.gif )

可以看到，样式修改生效了。

Button 组件支持的样式配置肯定不是 width、height，后面再完善就行。

我们把直接写 css 的方式也实现下：

![](./images/ccfd3e366edec8659804dd1b8e93864f.gif )

或者用类似 tailwind 的原子化 className 的方式，让用户自己选择，添加 className 也行：

![](./images/6461bf65d02700faa64e1fd9829f47a2.gif )

这样比写 css 上手成本低一些。

用 @monaco-editor/react 来做 css 编辑器，它自带了代码提示功能。

```
npm install --save @monaco-editor/react
```
封装个组件：

components/Setting/CssEditor.tsx
```javascript
import MonacoEditor, { OnMount, EditorProps } from '@monaco-editor/react'
import { editor } from 'monaco-editor'
import { useEffect, useRef } from 'react'

export interface EditorFile {
    name: string
    value: string
    language: string
}

interface Props {
    value: string
    onChange?: EditorProps['onChange']
    options?: editor.IStandaloneEditorConstructionOptions
}

export default function CssEditor(props: Props) {

    const {
        value,
        onChange,
        options
    } = props;

    const handleEditorMount: OnMount = (editor, monaco) => {
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyJ, () => {
          editor.getAction('editor.action.formatDocument')?.run()
      });
    }

    return <MonacoEditor
        height={'100%'}
        path='component.css'
        language='css'
        onMount={handleEditorMount}
        onChange={onChange}
        value={value}
        options={
            {
                fontSize: 14,
                scrollBeyondLastLine: false,
                minimap: {
                  enabled: false,
                },
                scrollbar: {
                  verticalScrollbarSize: 6,
                  horizontalScrollbarSize: 6,
                },
                ...options
            }
        }
    />
}
```
之前写 react playground 的时候用过 monoco editor。

这里配置差不多。

支持 cmd + J 快捷键来格式化。

然后在 ComponentStyle 组件里用一下：

![](./images/33da9a1f1e0aa4e1d52faf5809e6491c.webp )
```javascript
<div className='h-[200px] border-[1px] border-[#ccc]'>
    <CssEditor value={`.comp{\n\n}`}/>
</div>
```

试一下：

![](./images/7959b293b93dfcacd4cb6133f1185ac9.gif )

然后做下自定义 css 到 store 的同步：

onChange 的时候打印下值：

![](./images/2ff5d8cd84cf8dde3b623bfd88417458.webp )

![](./images/7eeace840df0e1c0b661785f3239e275.gif )

触发有点频繁了，我们引入 lodash 做下 debounce：

```
npm install --save lodash-es
npm install --save-dev @types/lodash-es
```

![](./images/7d8837420b8fb2fb4a2f2e5c282e9c7e.webp )

加个 500ms 的 debounce。

![](./images/e810e5867cd97b8bac42cf2d728e948d.gif )

这样就好多了。

然后把它保存到 store：

store 里保存的是 对象，而现在拿到的是 css 字符串，需要 parse 一下。

用 [style-to-object](https://www.npmjs.com/package/style-to-object) 这个包：

![](./images/df7a73ceac31dbde3de6be0d2f7447e2.webp )
调用下：

```javascript
const handleEditorChange = debounce((value) => {
    setCss(value);

    let css: Record<string, any> = {};

    try {
        const cssStr = value.replace(/\/\*.*\*\//, '') // 去掉注释 /** */
            .replace(/(\.?[^{]+{)/, '') // 去掉 .comp {
            .replace('}', '');// 去掉 }

        styleToObject(cssStr, (name, value) => {
            css[name.replace(/-\w/, (item) => item.toUpperCase().replace('-', ''))] = value;
        });

        console.log(css);
        updateComponentStyles(curComponentId, css);
    } catch(e) {}
}, 500);
```
style-to-object 只支持 style 的 parse：

![](./images/935634b66c4d1c385307bde84fb1769f.webp )

我们需要把注释、.comp { } 去掉

只保留中间部分。

然后 parse 完之后是 font-size、border-color 这种，转为驼峰之后更新到 store。

试一下：

![](./images/838a4e9de43b775eb0eeef18d17d25c2.gif )

可以看到，打印了 css parse 之后的对象并且更新到的 store。

中间的组件也应用了这个样式。

这时候上面的样式表单，下面直接写的 css 都能生效：

![](./images/57226e9dc8d0f406f9a8a1f94d6adb9b.gif )

但有个问题：

![](./images/8612b8315419de134035fb79a662dae7.gif )

删除这些 css 后，左边的样式不会消失。

因为我们更新 styles 的时候和已有的 style 做了合并：

![](./images/d793c7fcf0258c5730c2858dce580d7a.webp )

所以在编辑器里删除 css，合并后依然保留着之前的样式。

我们支持下整个替换就好了：

![](./images/702a163e9d991714e8ab3de9f1599e8d.webp )

![](./images/cf58c70016f84602cdca7dc8858f67a9.webp )
```javascript
component.styles = replace ? {...styles} : {...component.styles, ...styles};
```
如果 replace 参数传了 true，就整个替换 styles。

然后用的时候指定 replace 为 true：

![](./images/4ccc307e0f0666d86ac0bd16b1ea4615.webp )

```javascript
updateComponentStyles(curComponentId, {...form.getFieldsValue(), ...css}, true);
```

测试下：

![](./images/aa5a25a6f77f330992aa07161da34f70.gif )

现在两部分样式都会生效。

删除下面编辑器的样式也生效：

![](./images/ce5c23c9309a9f7519210cd2eb3418b5.gif )

现在还有个问题，切换选中的组件的时候，表单没清空：

![](./images/4417eb89dce0f4fbe1e25198080f753d.gif )

reset 一下就好了：

![](./images/1d1cdf5b50c4339ff264450b12945c41.webp )

```javascript
form.resetFields();
```
![](./images/80192397cac140df51e5da21c4866f6e.gif )

表单好了，下面的编辑器也重置下：

![](./images/bff883ba78086b335660b7cb6c22ba15.webp )

![](./images/3f0dbc5e5ff9cb324b6c02cb560ae51f.webp )

声明一个 css 的 state，curComponent 改变的时候设置 store 里的内容到 state。

然后 toCSSStr 方法就是拼接 css 字符串的。

要注意 with、height 要补 px，因为上面的表单的值保存的是数字。

```javascript
const [css, setCss] = useState<string>(`.comp{\n\n}`);

useEffect(() => {
    form.resetFields();

    const data = form.getFieldsValue();
    form.setFieldsValue({...data, ...curComponent?.styles});

    setCss(toCSSStr(curComponent?.styles!))
}, [curComponent])

function toCSSStr(css: Record<string, any>) {
    let str = `.comp {\n`;
    for(let key in css) {
        let value = css[key];
        if(!value) {
            continue;
        }
        if(['width', 'height'].includes(key) &&  !value.toString().endsWith('px')) {
            value += 'px';
        }

        str += `\t${key}: ${value};\n`
    }
    str += `}`;
    return str;
}
```
测试下：

![](./images/dccfd252250383e4cb3f486491c3e7d8.gif )

这样，当选中的组件切换的时候，样式的切换就完成了。

但还有一个问题：

![](./images/0f2a95fdf5bc7bb9743d2f7c3f8c9d2d.gif )

当样式改变的时候，编辑框的大小不会跟着改变。

但我们设置了 components 变化会 updatePosition 了呀：

![](./images/0c0ffb4c47bb35f457d96e233f75bec2.webp )

这是因为 components 变了，到渲染完成，然后再 getBoundingClientRect 拿到改变后的宽高是有一段时间的。

加个延迟就好了：

![](./images/0bd902ec776ab78a5fe1ab8a8befb98d.webp )

![](./images/3386dcdff415dd06cacb5f3e4f59a691.gif )

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/react-course-code/tree/main/lowcode-editor)，可以切换到这个 commit 查看：

```
git reset --hard 32a88a2f26100be09727cb6ba1c7c33d5f491523
```
## 总结

这节我们实现了属性和样式的编辑。

在 componentConfig 里加了 setter、stylesSetter 来保存不同组件的属性、样式表单配置。

然后在 Setting 区域渲染对应的表单。

表单变化的时候，修改 components 里对应的 styles、props 信息，传入组件渲染。

样式编辑我们还支持直接写 css，用 @monaco-editor/react 做的编辑器，然后编辑完用 style-to-object 转为对象后保存到 store。 

当然，现在 setter 的表单配置不够完善，当后面新加组件的时候，需要什么表单类型再扩展就行。
