# 114. 会议室预订系统：用户管理模块--用户列表和分页查询

用户管理模块我们实现了注册、登录鉴权、信息修改接口，还剩下两个接口：

![](./images/da05658d8f17f27d40f75acffda9971e.png )

这节来实现下。

在那之前先考虑个问题：

成功的响应是这样的：

![](./images/ad8136df019d1a16cf8f8bde551a5b78.png )

但是失败的响应是这样：

![](./images/2b39ed8e0290676f26aa0c85984cb195.png )

并不统一。

如何让响应统一成 {code、message、data} 的格式呢？

这里就需要自定义 Exception Filter 了。

![](./images/3ebdc516a1164448781886be9d3e3575.png )

在 Guard、handler、interceptor 等处理逻辑里 throw http 异常，都会被 ExceptionFilter 处理成相应的响应。

![](./images/f4566815c29ba656ce7012810745bee3.png )

![](./images/81b0953097281fcbd2769c3e2f015c63.png )

如果想修改异常响应的格式，就要自定义了。

我们新建个 exception filter：

```
nest g filter unlogin --flat
```

![](./images/406db269bf2d2dfff424f0b6bc9289ec.png )

@Catch 的参数可以指定具体 catch 的异常类型：

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

export class UnLoginException{
  message: string;

  constructor(message?){
    this.message = message;
  }
}

@Catch(UnLoginException)
export class UnloginFilter implements ExceptionFilter {
  catch(exception: UnLoginException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();

    response.json({
      code: HttpStatus.UNAUTHORIZED,
      message: 'fail',
      data: exception.message || '用户未登录'
    }).end();
  }
}
```
我们自定义了 UnLoginException 的异常，在 @Catch 指定捕获这个异常，返回对应的响应。

在 main.ts 引入下：

![](./images/28082c2db40cb5c2030211e78aec1782.png )

然后把 LoginGuard 里的异常改成 UnLoginException

![](./images/11af3e65faf2ae1b720b2ffadb823039.png )

测试下：

![](./images/8428f574862461212cb90780cd153124.png )

现在当你不带 token 访问 /aaa 的时候，返回的就是自己定义的格式了。

搜索下之前代码里抛的异常：

![](./images/418f89005653105b19275c52a92a555f.png )

还有不少。

难道有多少种 exception 就定义多少种异常类和 exception filter 么？

没必要，直接修改下对 HttpException 的处理逻辑就好了。

```
nest g filter custom-exception --flat
```

![](./images/bb19f654e0e9d248f2977ebf793f45b7.png )

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class CustomExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();
    response.statusCode = exception.getStatus();

    response.json({
      code: exception.getStatus(),
      message: 'fail',
      data: exception.message
    }).end();
  }
}
```
直接 @Catch 指定 HttpException，修改返回的响应格式。

然后在 main.ts 里启用：

![](./images/4e83efdbf3974b3552e96ee8697e7a96.png )

这样，所有的代码都不用修改，返回的响应就已经变了：

![](./images/1af508253e96664b836339a4867a6616.png )

![](./images/fa18259daeeecc32b11c4344481e441b.png )

所以，如果你只是想修改默认的响应格式，直接定义个 catch HttpException 的 filter 就好了。

但这样其实还有个问题：

![](./images/21896f805543143c94c1b5582e5c8e21.png )

对于 ValidationPipe 报的错，返回的信息不准。

我们可以打个断点看看具体的错误信息：

创建 .vscode/launch.json 文件：

输入调试配置：
```javascript
{
    "name": "Launch via NPM",
    "request": "launch",
    "runtimeArgs": [
        "run-script",
        "start:dev"
    ],
    "console": "integratedTerminal",
    "runtimeExecutable": "npm",
    "skipFiles": [
        "<node_internals>/**"
    ],
    "type": "node"
}
```
然后在 exception filter 打个断点，点击调试启动：

![](./images/9904a12100aa794c923765fde987a4a1.png )

在 postman 里再次请求这个接口，代码会在断点处断住：

![](./images/483b5aa4996fb7263597f1e0aaeb15fd.png )

可以看到，这时候 message 并不是具体的错误，具体的错误在 response.message 里：

![](./images/d32b2a004621202e46dd6ba4b833e873.png )

所以我们可以这样改：

![](./images/cb04649d8c2f2454fdea26cca5f2c561.png )

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class CustomExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();
    response.statusCode = exception.getStatus();

    const res = exception.getResponse() as { message: string[] };
    
    response.json({
      code: exception.getStatus(),
      message: 'fail',
      data: res?.message?.join ? res?.message?.join(',') : exception.message
    }).end();
  }
}

```

就是如果有 response.message 就优先用那个，否则就取 exception.message。

再试下：

![](./images/d4cdd0e82dbbaa45debe8b037167591e.png )

这样，错误显示就对了。

然后我们实现冻结用户的接口，冻结的用户不能预定会议室。

![](./images/027983c32d4b246c18c6a583385b92f4.png )

这个接口非常简单，就是修改一个字段：

![](./images/43bc1048dec273a8fb4005f20046538d.png )

```javascript
@Get('freeze')
async freeze(@Query('id') userId: number) {
    await this.userService.freezeUserById(userId);
    return 'success';
}
```
定义 get 接口，然后从 query 取 id 参数。

其实这个接口也需要登录，而且只有管理员有调用它的权限，这个我们后面再统一处理。

在 UserService 定义这个 freezeUserById 方法：

```javascript
async freezeUserById(id: number) {
    const user = await this.userRepository.findOneBy({
        id
    });

    user.isFrozen = true;

    await this.userRepository.save(user);
}
```

测试下：

![](./images/eefa3886a017e965995ff08b8b63af8d.png )

![](./images/ce124d693c13e6cb00598e30a83049a3.png )

确实冻结了。

然后实现 /user/list 用户列表接口。

```javascript
@Get('list')
async list(@Query('pageNo', ParseIntPipe) pageNo: number, @Query('pageSize', ParseIntPipe) pageSize: number) {
    return await this.userService.findUsersByPage(pageNo, pageSize);
}
```
这个接口支持分页查询，传入 pageNo、pageSize，返回对应页的数据。

我们在 UserService 里实现下：

还记得如何用 sql 实现分页查询么？

目前 users 表有 4 条数据，我们先查询全部的：

```sql
select * from users
```
![](./images/aa41c83b013fa00d87fb8294950624bf.png )

然后每 2 条记录一页

查询第一页：

```sql
select * from users limit 0,2
```

![](./images/f764ad58235b9ee9a0280e05398657ff.png )

查询第二页：

```sql
select * from users limit 2,2
```
![](./images/a34782cd649b81ee7148508c7d176fa1.png )

也就是说，只要计算出当前页码跳过多少条记录，取多少条记录就好了。

也就是这样：

```javascript
async findUsersByPage(pageNo: number, pageSize: number) {
    const skipCount = (pageNo - 1) * pageSize;

    const [users, totalCount] = await this.userRepository.findAndCount({
        skip: skipCount,
        take: pageSize
    });

    return {
        users,
        totalCount
    }
}
```
当前页码减一乘以 pageSize，就是要跳过的记录数，然后再取 pageSize 条。

我们这次用的是 findAndCount 的 api，它还会查询总记录数。

测试下：

![](./images/ac66ee4f266e3fa0b2a8aa47ed73394d.png )

没传 pageNo 的时候会返回 400 的错误。

这个报错信息不够友好，我们改一下：

```javascript
@Get('list')
async list(
@Query('pageNo', new ParseIntPipe({
  exceptionFactory() {
    throw new BadRequestException('pageNo 应该传数字');
  } 
})) pageNo: number,
@Query('pageSize', new ParseIntPipe({
  exceptionFactory() {
    throw new BadRequestException('pageSize 应该传数字');
  } 
})) pageSize: number
) {
    return await this.userService.findUsersByPage(pageNo, pageSize);
}
```

![](./images/2678cd8ebcf0030b0f4bea8b490877b8.png )

![](./images/3718efbca3c2ebbf415d2d2ed5fa8a37.png )

现在的提示信息就友好多了。

我们重构下代码：

把这段代码抽离到 src/utils.ts 里：

```javascript
export function generateParseIntPipe(name) {
    return new ParseIntPipe({
      exceptionFactory() {
        throw new BadRequestException(name + ' 应该传数字');
      } 
    })
}
```
那 controller 的代码就可以简化成这样了：

```javascript
@Get('list')
async list(
    @Query('pageNo', generateParseIntPipe('pageNo')) pageNo: number,
    @Query('pageSize', generateParseIntPipe('pageSize')) pageSize: number,
) {
    return await this.userService.findUsersByPage(pageNo, pageSize);
}
```
那如果没有传 pageNo 和 pageSize 的时候要设置个默认值呢？

可以使用 DefaultValuePipe：

![](./images/2b4cf5d77bb3735db196da06bf4e4510.png )

没有传 pageNo 的时候设置为 1，没有传 pageSize 的时候设置为 2。

测试下：

![](./images/7601e01c62609ca727651671c1bae5a9.png )

现在传入 pageNo 和 pageSize 就可以查询出对应的数据，还有总条数：

![](./images/1a7dcf537548d3721afe5ee61131b253.png )

服务端打印了两条 sql：

![](./images/57823ede1be305f5b046f5cf6337ff55.png )

一条是分页查询，指定了 limit 2 offset 2，这个和 limit 2, 2 是一样的

一条是 count 统计，统计了用户的总条数。

这里返回的信息同样也需要做一些修改。

我们指定下 select 的字段：

```javascript
async findUsersByPage(pageNo: number, pageSize: number) {
    const skipCount = (pageNo - 1) * pageSize;

    const [users, totalCount] = await this.userRepository.findAndCount({
        select: ['id', 'username', 'nickName', 'email', 'phoneNumber', 'isFrozen', 'headPic', 'createTime'],
        skip: skipCount,
        take: pageSize
    });

    return {
        users,
        totalCount
    }
}
```
这样返回的数据就只包含 select 的字段了：

![](./images/58d823afa82e5f797bba21916555b900.png )

当然，如果你需要对返回的数据再做一些变换，这时候可以封装个 vo 对象。

用户列表的需求除了分页外，还需要支持根据 username、nickName、email 的搜索：

![](./images/027983c32d4b246c18c6a583385b92f4.png )

添加几个参数：

```javascript
@Get('list')
async list(
    @Query('pageNo', new DefaultValuePipe(1), generateParseIntPipe('pageNo')) pageNo: number,
    @Query('pageSize', new DefaultValuePipe(2), generateParseIntPipe('pageSize')) pageSize: number,
    @Query('username') username: string,
    @Query('nickName') nickName: string,
    @Query('email') email: string
) {
    return await this.userService.findUsers(username, nickName, email, pageNo, pageSize);
}
```
在 UserService 添加 findUsers 方法：

```javascript
async findUsers(username: string, nickName: string, email: string, pageNo: number, pageSize: number) {
    const skipCount = (pageNo - 1) * pageSize;

    const condition: Record<string, any> = {};

    if(username) {
        condition.username = Like(`%${username}%`);   
    }
    if(nickName) {
        condition.nickName = Like(`%${nickName}%`); 
    }
    if(email) {
        condition.email = Like(`%${email}%`); 
    }

    const [users, totalCount] = await this.userRepository.findAndCount({
        select: ['id', 'username', 'nickName', 'email', 'phoneNumber', 'isFrozen', 'headPic', 'createTime'],
        skip: skipCount,
        take: pageSize,
        where: condition
    });

    return {
        users,
        totalCount
    }
}
```
和之前的区别就是多了个 where 条件。

根据 username、nickName、email 搜索的时候，使用模糊查询。

测试下：

![](./images/995de8aef0c9bb6df530abc1a3ae0cad.png )

当我传 nickName 包含“里”的时候，服务端查询到数据只有一条。

![](./images/36a8a11a71cd08be298bdc600af16c0b.png )

传入 nickName 包含 “光” 的时候，返回两条数据。

这样，搜索就完成了。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们实现了冻结用户和用户列表接口。

我们通过自定义 exception filter，catch 了 HTTPException，返回了自定义格式的响应，统一了响应格式。

冻结用户接口比较简单，就是修改 users 表的一个字段。

用户列表支持了分页查询和模糊搜索：

分页查询就是根据 (pageNo -1) \* pageSize 计算出从哪里开始，然后取 pageSize 条。

模糊搜索就是通过 like 来匹配。

此外，ParseIntPipe 我们自定义了错误格式，还使用了 DefaultValuePipe 设置了默认值。

至此，用户模块的所有接口都写完了，下节我们用 swagger 来生成接口文档。