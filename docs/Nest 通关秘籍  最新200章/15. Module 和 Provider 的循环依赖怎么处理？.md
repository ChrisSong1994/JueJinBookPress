# 15. Module 和 Provider 的循环依赖怎么处理？

Nest 实现了一套模块系统，模块可以通过 imports 声明对其他模块的引用。

那 Module 和 Module 如果相互引用、形成循环依赖了怎么办？

这节我们就来学习下循环依赖的处理方式。

执行

```
nest new module-test -p npm
```
创建一个 nest 项目。

然后执行
```
nest g module aaa
nest g module bbb
```
创建两个 Module。

![](./images/12623a3b2048ef17ff21abf035cd4c02.webp )

然后这两个 Module 相互引用。

![](./images/ee985ede9dc98c7f8a9fcc9535329af0.webp )

![](./images/716c3ca8ca888bca61b07e7640a6fd32.webp )

这时候你执行

```
nest start -w
```
把服务跑起来，会报这样的错误：

![](./images/23e8cd8b2ab849a45c6122b18dcfa249.webp )

意思是在解析 BbbModule 的时候，它的第一个 imports 是 undefined。

这有两个原因，一个是这个值本来就是 undefined，第二个就是形成了循环依赖。

因为 Nest 创建 Module 的时候会递归创建它的依赖，而它的依赖又依赖了这个 Module，所以没法创建成功，拿到的就是 undefined。

![](./images/53e989c40d5858dd4b8a2f23bc27a6c3.webp )

那怎么办呢？

其实我们可以先单独创建这两个 Module，然后再让两者关联起来。

也就是用 forwardRef 的方式：

![](./images/1eaf9cb488b153a9fede3f658655465d.webp )

![](./images/afd498b549322f525905ac35dd9284ed.webp )

因为我们用了 nest start --watch 的方式启动的，nest 会自动重启，这时候就没有错误了：

![](./images/0c291b9463c2ce582195049d70e88214.webp )

nest 会单独创建两个 Module，之后再把 Module 的引用转发过去，也就是 forwardRef 的含义。

![](./images/f11527f16ee586ea541105da478e4089.webp )

除了 Module 和 Module 之间会循环依赖以外，provider 之间也会。

比如 Service 里可以注入别的 Service，自身也可以用来注入。

所以也会有循环引用。

我们来测试下：

```
nest g service ccc --no-spec --flat
nest g service ddd --no-spec --flat
```
![](./images/fb50647441ddf6dcd9b952f9fc5306e0.webp )

分别创建 ccc 和 ddd 两个 service，--no-spec 是不生成测试文件，--flat 是平铺。

就会创建这两个 service，并在 AppModule 引入了：

![](./images/b50bd38c62bde9781a4ada78041a3db2.webp )

![](./images/cedd5288fa61447593331de4f2f11658.webp )

![](./images/88492d7c529b119e11e2745042f2caab.webp )

然后我们让两者相互注入：

```javascript
import { Injectable } from '@nestjs/common';
import { CccService } from './ccc.service';

@Injectable()
export class DddService {
    constructor(private cccService: CccService) {}

    ddd() {
        return this.cccService.ccc()  + 'ddd';
    }
}
```

```javascript
import { Injectable } from '@nestjs/common';
import { DddService } from './ddd.service';

@Injectable()
export class CccService {
    constructor(private dddService: DddService) {}

    ccc() {
        return 'ccc';
    }

    eee() {
        return this.dddService.ddd() + 'eee';
    }
}
```

两个 service 分别依赖了对方的方法。

在 AppService 里调用下：

```javascript
import { Injectable } from '@nestjs/common';
import { CccService } from './ccc.service';
import { DddService } from './ddd.service';

@Injectable()
export class AppService {
  constructor(private cccService: CccService, private dddService: DddService){}

  getHello(): string {
    return this.dddService.ddd() + this.cccService.eee();
  }
}
```

这时候 nest start --watch 会报错：

![](./images/a2ab82bf725adb05d06e9651820ae2f9.webp )

说是没法解析 DddService 的依赖，也是因为循环依赖导致的。

这时候也是通过 forwardRef 解决：

![](./images/a8d4190517f3b1e98a2bbacf4f4c25f2.webp )

![](./images/6445bb98e59c7ee92e7da41aeebd1923.webp )

这时候就不能用默认的注入方式了，通过 @Inject 手动指定注入的 token，这里是 forwardRef 的方式注入。

这样报错就没了：

![](./images/80367d9dd5aa7f3a09a58a5d1973fc51.webp )

浏览器访问下：

![](./images/8e36d25169c20ff7527110bec14bf303.webp )

两个 service 的相互调用也成功了。

这样我们就解决了循环依赖的问题。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/circular-dependency)。

## 总结

Module 之间可以相互 imports，Provider 之间可以相互注入，这两者都会形成循环依赖。

解决方式就是两边都用 forwardRef 来包裹下。

它的原理就是 nest 会先创建 Module、Provider，之后再把引用转发到对方，也就是 forward ref。

