# 91. 定时任务 + Redis 实现阅读量计数

文章都会有个阅读量，那这个阅读量是怎么计数的呢？

![](./images/0af49b5100ce4d219ed493d2916cf8ee.png )

有同学说，很简单啊，这不就是文章表里加个 views 的字段，然后每次刷新页面都加一么？

这样是可以，但有两个问题：

- 每次刷新阅读量都加一，其实还是同一个人看的这篇文章，这样统计出来的阅读量是不准的，我们想要的阅读量是有多少人看过这篇文章

- 阅读是个很高频的操作，直接存到数据库，数据库压力会太大

这两个问题分别都怎么解决呢？

其实我们学完 Redis 就应该能想到解决方案了：

- 在 redis 中存储 user 和 article 的关系，比如 user_111_article_222 为 key，10 分钟后删除，如果存在这个 key，就说明该用户看过这篇文章，就不更新阅读量，否则才更新

    10 分钟后，这个人再看这篇文章，就可以算是新的一次阅读量了。

- 访问文章时把阅读量加载到 redis，之后的阅读量计数只更新 redis，不更新数据库，等业务低峰期再把最新的阅读量写入数据库

    这里在业务低峰期，比如凌晨 4 点的时候写入数据库，可以用定时任务来做。


思路理清了，我们来实现一下：

```
nest new article-views -p npm
```

![](./images/694d7739dbc6365f0c5971a2f6e9267a.png )

创建个 nest 项目。

安装 typeorm 相关的包：

```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [ 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "article_views",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
在 mysql workbench 里创建这个 database

```
CREATE DATABASE article_views DEFAULT CHARACTER SET utf8mb4;
```

![](./images/890ce6b8c86291de9bef8bbd40ccb8f2.png )

刷新可以看到这个 database

![](./images/3bb3af1b00bc4f251d8d0b623873e367.png )

然后建个文章和用户的模块：

```javascript
nest g resource user --no-spec
nest g resource article --no-spec
```

![](./images/b896357b4343d6c784749a078808bcaa.png )

添加 user 和 article 的 entity

```javascript
import { Column, PrimaryGeneratedColumn, Entity } from "typeorm";

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        comment: '用户名'
    })
    username: string;

    @Column({
        comment: '密码'
    })
    password: string;
}
```
```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class Article {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        comment: '文章名字',
        length: 50
    })
    title: string;

    @Column({
        comment: '内容',
        type: 'text'
    })
    content: string;

    @Column({
        comment: '阅读量',
        default: 0
    })
    viewCount: number;

    @Column({
        comment: '点赞量',
        default: 0
    })
    likeCount: number;

    @Column({
        comment: '收藏量',
        default: 0
    })
    collectCount: number;
}

```
在 entities 引入：

![](./images/26a831a5fbb9cab61303d51eed9beece.png )

可以看到 typeorm 自动创建了这两个表：

![](./images/d536d1a915fd11d1d4fb812093c90433.png )

然后插入一些数据：

在 AppController 创建 init-data 的路由，然后注入 EntityManager：

![](./images/e26fb6bccc7e81f7761c1b50bdae9668.png )

```javascript
@InjectEntityManager()
  private entityManager: EntityManager;

  @Get('init-data')
  async initData() {
    await this.entityManager.save(User, {
      username: 'dong',
      password: '111111'
    });
    await this.entityManager.save(User, {
      username: 'guang',
      password: '222222'
    });

    await this.entityManager.save(Article, {
      title: '基于 Axios 封装一个完美的双 token 无感刷新',
      content: `用户登录之后，会返回一个用户的标识，之后带上这个标识请求别的接口，就能识别出该用户。

      标识登录状态的方案有两种： session 和 jwt。
      `
    });

    await this.entityManager.save(Article, {
      title: 'Three.js 手写跳一跳小游戏',
      content: `前几年，跳一跳小游戏火过一段时间。

      玩家从一个方块跳到下一个方块，如果没跳过去就算失败，跳过去了就会再出现下一个方块。`
    });
    return 'done';
  }
```
两个 entity 分别插入 2 条数据。

浏览器访问下：

![](./images/3ea3d8b52d1c9435e3d2d2c2715f458a.png )


可以看到 4 条 insert 语句：

![](./images/b087e8eea6530ba29fda04a55f2d9aa4.png )

在 mysql workbench 里也可以看到两个表都插入了数据：

![](./images/1d3ee01f08642bfd0ab9a55f7433c75e.png )

![](./images/12c3cce2893d97173fda5b6fa1e24f79.png )

然后先实现登录：

这次用 session 的方案：

安装相关的包：
```
npm install express-session @types/express-session
```
在 main.ts 里启用：

![](./images/b0023b02aa8369f2a1dd53ec4efea7e8.png )

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as session from 'express-session';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.use(session({
    secret: 'guang',
    resave: false,
    saveUninitialized: false
  }));

  await app.listen(3000);
}
bootstrap();
```

然后实现下登录：

在 UserController 添加 login 的路由：

```javascript
@Post('login')
async login(@Body() loginUserDto: LoginUserDto) {
    console.log(loginUserDto);
    return 'success';
}
```
新建 src/user/dto/login-user.dto.ts

```javascript
export class LoginUserDto {
    username: string;

    password: string;
}
```
测试下：

![](./images/857cfe160460ec2e37a696d5a13957bc.png )

![](./images/261e4ae875ab9ce826b5f42f6cc5ecc5.png )

然后在 UserService 实现登录逻辑：

```javascript
@InjectEntityManager()
private entityManager: EntityManager;

async login(loginUser: LoginUserDto) {
    const user = await this.entityManager.findOne(User, {
      where: {
        username: loginUser.username
      }
    });

    if(!user) {
      throw new BadRequestException('用户不存在');
    }

    if(user.password !== loginUser.password) {
      throw new BadRequestException('密码错误');
    }

    return user;
}
```
在 UserController 调用下：

```javascript
@Post('login')
async login(@Body() loginUserDto: LoginUserDto, @Session() session) {
    const user = await this.userService.login(loginUserDto);

    session.user = {
        id: user.id,
        username: user.username
    }

    return 'success';
}
```
调用 userService 的 login 方法，实现登录验证，然后把用户信息存入 session。

当用户不存在时：

![](./images/64d17df8a9a937e795bb5540e8e88135.png )

当密码错误时：

![](./images/30aa69d9da7d85d7f772a0b91325daf1.png )

登录成功时：

![](./images/7e38f9bde7769cd69ea5562755ba78f8.png )

然后在 ArticleController 添加一个查询文章的接口：

```javascript
@Get(':id')
async findOne(@Param('id') id: string) {
    return await this.articleService.findOne(+id);
}
```
实现 articleService.findOne 方法：

```javascript
@InjectEntityManager()
private entityManager: EntityManager;

async findOne(id: number) {
    return await this.entityManager.findOneBy(Article, {
      id
    });
}
```
测试下：

![](./images/95e80a4babe277574680f287b0723355.png )

然后我们在 ArticleController 加一个阅读的接口：

```javascript
@Get(':id/view')
async view(@Param('id') id: string) {
    return await this.articleService.view(+id);
}
```
然后在 ArticleService 里实现具体的逻辑：

```javascript
async view(id: number) {
    const article = await this.findOne(id);

    article.viewCount ++;

    await this.entityManager.save(article);

    return article.viewCount;
}
```
测试下：

![](./images/cbe5b756cd74e3409594d092156befff.gif )

数据库里阅读量确实更新了：

![](./images/3a81d81252aa8c282e9ac680e6fe9545.png )

再次查询出来的就是新的阅读量：

![](./images/5415083047d963d43b790cb00d1c0878.png )

这样是能实现功能，但有前面我们讲到的两个问题：

- 每次刷新阅读量都加一，其实还是同一个人看的这篇文章，这样统计出来的阅读量是不准的，我们想要的阅读量是有多少人看过这篇文章

- 阅读是个很高频的操作，直接存到数据库，数据库压力会太大

所以，我们要引入 redis。

安装 redis 的包：

```
npm install --save redis
```

然后创建个 redis 模块：

```
nest g module redis
nest g service redis
```

![](./images/05fe13cd2d8464a8b668cd26d9b0840a.png )

在 RedisModule 创建连接 redis 的 provider，导出 RedisService，并把这个模块标记为 @Global 模块

```javascript
import { Global, Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```

然后在 RedisService 里注入 REDIS_CLIENT，并封装一些方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async get(key: string) {
        return await this.redisClient.get(key);
    }

    async set(key: string, value: string | number, ttl?: number) {
        await this.redisClient.set(key, value);

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }

    async hashGet(key: string) {
        return await this.redisClient.hGetAll(key);
    }

    async hashSet(key: string, obj: Record<string, any>, ttl?: number) {
        for(let name in obj) {
            await this.redisClient.hSet(key, name, obj[name]);
        }

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```
我们封装了 get、set、hashGet、hashSet 方法，分别是对 redis 的 string、hash 数据结构的读取。

然后在 view 方法里引入 redis：

```javascript
@Inject(RedisService)
private redisService: RedisService;

async view(id: number) {
    const res = await this.redisService.hashGet(`article_${id}`);

    if(res.viewCount === undefined) {
      const article = await this.findOne(id);

      article.viewCount ++;

      await this.entityManager.save(article);

      await this.redisService.hashSet(`article_${id}`, {
        viewCount: article.viewCount,
        likeCount: article.likeCount,
        collectCount: article.collectCount
      });

      return article.viewCount;

    } else {
      await this.redisService.hashSet(`article_${id}`, {
        ...res,
        viewCount: +res.viewCount + 1
      });
      return +res.viewCount + 1;
    }
}
```
先查询 redis，如果没查到就从数据库里查出来返回，并存到 redis 里。

查到了就更新 redis 的 viewCount，直接返回 viewCount + 1

测试下：

![](./images/2d36bb21b18975eccd71530a24fa2203.png )

服务端打印了 3 条 sql：

![](./images/332154aefc09df76b795f9379750e550.png )

redis 里也有了这个 hash 的结构：

![](./images/dc6dc5e48aa74b2e58d300a3747418c6.png )

为什么是 3 条呢？

因为 findOne 发一条 select，save 会先发一条 select，再发一条 update。

我们可以优化一下，把 save 换成 update：

![](./images/af75c30d95a784a323c83c6de2a5534d.png )

```javascript
await this.entityManager.update(Article, {  id }, {
    viewCount: article.viewCount
});
```
然后把 redis 那条数据删掉：

![](./images/a78b45bcd227c7c69c78b19aeef4befb.png )

重新跑一下：

![](./images/76ace1f96511eef4ad4427a0755c2535.png )

现在就只有一条 select、一条 update 了。

![](./images/6bc1c747b59728cafeea71e49f092885.png )

然后多刷新几次：

![](./images/3c5a074bb8e6729dfdba3c40fe3b32ad.gif )

没发送 sql，还是之前那两条：

![](./images/47be414ac19bdaa4d04b860a9cfbf82c.png )

因为这时候查的是 redis。

redis 里数据更新了：

![](./images/4b10865e8f5ac8545ce6ff0d0f7f438b.png )

但是数据库里的 viewCount 还是 8

![](./images/904925ba13231dc126a321dec4f55567.png )

这样一重启 redis 数据就没了。

所以还要同步到数据库。

同步倒是不用很频繁，可以放在凌晨 4 点，访问量少的时候通过定时任务同步数据库。

我们需要引入定时任务包 @nestjs/schedule

```
npm install --save @nestjs/schedule
```

在 AppModule 引入下：

![](./images/9c29e628e9472dbed5131409e2927d35.png )

然后创建一个 service：
```
nest g module task
nest g service task
```
![](./images/6f0dbba9a4ea0097fb57cf6d579b6d7b.png )

定义个方法，通过 @Cron 声明每 10s 执行一次：

```javascript
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class TasksService {

  @Cron(CronExpression.EVERY_10_SECONDS)
  handleCron() {
    console.log('task execute')
  }
}
```
然后就可以看到控制台会每 10s 打印一次

![](./images/9aadc31ab4a7ff3379be15b96708d2c2.png )

我们在 TaskModule 引入 ArticleModule：

```javascript
import { Module } from '@nestjs/common';
import { TaskService } from './task.service';
import { ArticleModule } from 'src/article/article.module';

@Module({
  imports: [
    ArticleModule
  ],
  providers: [TaskService]
})
export class TaskModule {}
```
并且在 ArticleModule 导出 ArticleService

![](./images/3b70c76f8084ef1d4b9fcb600e3003dc.png )

然后在 TaskService 里注入 articleService 
```javascript
import { Inject, Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { ArticleService } from 'src/article/article.service';

@Injectable()
export class TaskService {

  @Inject(ArticleService)
  private articleService: ArticleService;

  @Cron(CronExpression.EVERY_MINUTE)
  async handleCron() {
    await this.articleService.flushRedisToDB();
  }
}
```

每分钟执行一次，调用 articleService 的 flushRedisToDB 方法。

然后我们实现这个方法：

先在 RedisService 添加一个 keys 方法，用来查询 key：

![](./images/ba429bc9ee404791dde6c6147d764387.png )

```javascript
async keys(pattern: string) {
    return await this.redisClient.keys(pattern);
}
```
然后在 ArticleService 里实现同步数据库的逻辑：

```javascript
async flushRedisToDB() {
    const keys = await this.redisService.keys(`article_*`);
    console.log(keys);
}
```

我们先打印下 keys。

![](./images/c802afffce83bc8f4a283877965def63.png )

现在只有一个 key，我们再访问下另一篇文章


![](./images/49fc13127cb07e2baa7758a336163ed8.png )

现在就有 2 个 key 了：

![](./images/1bd8599dee50fc244b213a4f785d17e4.png )

我们把所有的 key 对应的值存入数据库：

```javascript
async flushRedisToDB() {
    const keys = await this.redisService.keys(`article_*`);

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];

      const res = await this.redisService.hashGet(key);

      const [, id] = key.split('_');

      await this.entityManager.update(Article, {
        id: +id
      }, {
        viewCount: +res.viewCount,        
      });
    }
}
```

查询出 key 对应的值，更新到数据库。

测试下：
  
![](./images/7146a60a10f81d3fd44b82e5a733e092.gif )

刷新几次 view 接口，redis 里阅读量增加了：

![](./images/a8dc06b96bf93edf392032b774f8895d.png )

但是数据库里没变：

![](./images/37e69e7bb967f3badbf71c11b264eb3f.png )

过了一会，控制台打印了 2 条 update 语句：

![](./images/6c2c950f0cc0668060ffd3b6fb4738ec.png )

数据库里的数据就更新了：

![](./images/90a96bc67ed2e5ac3017540ab5172268.png )

接下来只要把定时任务的执行时间改为 4 点就好了：

![](./images/7d126145e7a6cd2845211547454a3f86.png )

```javascript
@Cron(CronExpression.EVERY_DAY_AT_4AM)
```
这样，基于 redis 的阅读量缓存，以及定时任务更新数据库就完成了。

还有剩下的一个问题：

- 每次刷新阅读量都加一，其实还是同一个人看的这篇文章，这样统计出来的阅读量是不准的，我们想要的阅读量是有多少人看过这篇文章

我们可以在用户访问文章的时候在 redis 存一个 10 分钟过期的标记，有这个标记的时候阅读量不增加。

![](./images/82662a39aed836297eb254e8f5e50c54.png )

```javascript
await this.redisService.set(`user_${userId}_article_${id}`, 1, 3);
```
为了测试方便，我们先设置 3s 过期。

```javascript
const flag = this.redisService.get(`user_${userId}_article_${id}`);

if(flag) {
    return res.viewCount;
}
```
这里需要传入 userId。

我们在 ArticleController 的 view 方法里传入下：

```javascript
@Get(':id/view')
async view(@Param('id') id: string, @Session() session, @Req() req) {
    return await this.articleService.view(+id, session?.user?.id || req.ip);
}
```

试试看：

![](./images/64e02cd61d696deba2da385e47e3fbc3.gif )

可以看到，现在就不是每次刷新都增加阅读量了，而是 3s 之后再刷新才增加。

在 redis 里可以看到这个 key：

![](./images/e8cb5c16210574812a3261e0652af716.png )

只不过现在没登录，用的是 ip，而本地访问的时候获取的 ip 就是 ::1 这样的，线上就能拿到具体的 ip 了。

然后我们登录下再访问：

![](./images/f7e58b38007f658184819ec8b3a130aa.png )

![](./images/f58e20ae8ba5e577d761abdaa97c5310.png )

这时用的就是用户 id 了：

![](./images/9c8d9acdd4d0b1d4820139a0c1402515.png )

这样就实现了真实的阅读量计数。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/article-views)。

## 总结

我们通过 redis + 定时任务实现了阅读量计数的功能。

因为阅读是个高频操作，所以我们查出数据后存在 redis里，之后一直访问 redis 的数据，然后通过定时任务在凌晨 4 点把最新数据写入数据库。

并且为了统计真实的用户阅读量，我们在 redis 存储了用户看了哪篇文章的标识，10 分钟后过期。

这就是我们常见的阅读量功能的实现原理。
