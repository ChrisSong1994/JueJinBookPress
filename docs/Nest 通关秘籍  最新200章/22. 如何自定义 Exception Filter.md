# 22. 如何自定义 Exception Filter

Exception Filter 是在 Nest 应用抛异常的时候，捕获它并返回一个对应的响应。

比如路由找不到时返回 404：

![](./images/57ba1e7d551b8a861730109a53e36af8.webp )

服务端报错时返回 500：

![](./images/53741c72ba251a8fadf3baef9b2338c3.webp )

参数的错误返回 400：

![](./images/b18a6a1bdfba17a4f0da15665f230eb6.webp )

这些都是 Exception Filter 做的事情。

那么，如果我们想自定义异常时返回的响应格式呢？

这种就要自定义 Exception Filter 了。

创建个 nest 项目：

```
nest new exception-filter-test
```
![](./images/8e5f9ca3e3965dee7a3006244243f05e.webp )

把它跑起来：

```
npm run start:dev
```

![](./images/c1bd1431ab4006462c7e40bd4feb56ec.webp )

浏览器访问 http://localhost:3000 可以看到 hello world，代表服务跑起来了：

![](./images/e48232afacc65e853a42cffd44cc46cb.webp )

然后在 controller 里抛个异常： 

![](./images/a72aabb86b9d105e984bc57e8ba0b0eb.webp )

```javascript
throw new HttpException('xxxx', HttpStatus.BAD_REQUEST)
```
这个 HttpStatus 就是一些状态码的常量：

![](./images/b7777ece032bd8d474b64cf1a3b82c5f.gif )

这时候刷新页面，返回的就是 400 对应的响应：

![](./images/7125b79abb821c0e59b16246770a0966.webp )

这个响应的格式是内置的 Exception Filter 生成的。

当然，你也可以直接抛具体的异常：

![](./images/19166597702f79dbd43bead284f4f4b9.webp )

![](./images/3f787b21e998f027a3e58da6d8cfef39.webp )

然后我们自己定义个 exception filter：

```
nest g filter hello --flat --no-spec
```

--flat 是不生成 hello 目录，--no-spec 是不生成测试文件。

![](./images/84d0869ce980bc207e5f10dfafeb0a5f.webp )

![](./images/00c6ae7fb4177c4c6cc399405cecbde6.webp )

@Catch 指定要捕获的异常，这里指定 BadRequestException。


```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter } from '@nestjs/common';

@Catch(BadRequestException)
export class HelloFilter implements ExceptionFilter {
  catch(exception: BadRequestException, host: ArgumentsHost) {
    debugger;
  }
}
```
先打个断点。

在 AppModule 里引入：

![](./images/1da2885ae37e6151250a6f85208d479e.webp )

```javascript
app.useGlobalFilters(new HelloFilter());
```
如果你想局部启用，可以加在 handler 或者 controller 上：

![](./images/953f7a9abf7a72af51d0ac988b9bf89c.webp )

![](./images/3586acf8a8a55e63519b2f2d898dd9e3.webp )

然后新建个调试配置文件：

![](./images/0372bdbeb10e76e5ffca0c580a8d2b9f.webp )

输入调试配置：

![](./images/ac1cebbaea855e6116df2e154c9c0c5c.webp )

```json
{
    "type": "node",
    "request": "launch",
    "name": "debug nest",
    "runtimeExecutable": "npm",
    "args": [
        "run",
        "start:dev",
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "console": "integratedTerminal",
}
```
把之前的服务关掉，点击调试启动：

![](./images/68f576cf15c39180b7203da88786156a.webp )

刷新页面，代码会在断点处断住：

![](./images/8eb45ce0e1826bbeede10d04502ebe48.webp )

我们只要根据异常信息返回对应的响应就可以了：

![](./images/9f9db8b61f52e51325de8dc019f806b6.webp )

```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter, HttpException } from '@nestjs/common';
import { Response } from 'express';

@Catch(BadRequestException)
export class HelloFilter implements ExceptionFilter {
  catch(exception: BadRequestException, host: ArgumentsHost) {
    const http = host.switchToHttp();
    const response = http.getResponse<Response>();

    const statusCode = exception.getStatus();

    response.status(statusCode).json({
       code: statusCode,
       message: exception.message,
       error: 'Bad Request',
       xxx: 111
    })
  }
}

```
这样，抛异常时返回的响应就是自定义的了：

![](./images/b76a9f534231ce3e381799a64645e894.webp )

但我们只是 @Catch 了 BadRequestException

如果抛的是其他异常，依然是原来的格式：

![](./images/d566ab4241b179d6691994c7adcde389.webp )

比如我抛一个 BadGatewayException。

![](./images/717cb838c3e39109f773ae34f66b0af1.webp )

依然是默认格式。

那我们只要 @Catch 指定 HttpException 不就行了？

因为 BadRequestExeption、BadGateWayException 等都是它的子类。

![](./images/bcfe920c9503684857a227f15afdb072.webp )

试一下：

![](./images/81962f2ca0e56d19375298b3a09aabb2.webp )

![](./images/36e678a71e5591bb4297e65a06442e14.webp )

确实，现在所有的 HttpException 都会被处理了。

但其实这也有个问题。

就是当我们用了 ValidationPipe 的时候。

比如我们加一个路由：

```javascript
@Post('aaa') 
aaa(@Body() aaaDto: AaaDto ){
    return 'success';
}
```
然后创建 src/aaa.dto.ts

```javascript
export class AaaDto {
    aaa: string;
    
    bbb: number;
}
```
安装用到的包：

```
npm install --save class-validator class-transformer
```
然后给 AaaDto 添加几个校验规则：

```javascript
import { IsEmail, IsNotEmpty, IsNumber } from "class-validator";

export class AaaDto {
    @IsNotEmpty({message: 'aaa 不能为空'})
    @IsEmail({}, {message: 'aaa 不是邮箱格式'})
    aaa: string;
    
    @IsNumber({}, {message: 'bbb 不是数字'})
    @IsNotEmpty({message: 'bbb 不能为空'})
    bbb: number;
}
```
在 main.ts 启用 ValidationPipe：

![](./images/0646be959887c95d3a5f9c8e5d667aca.webp )

```javascript
app.useGlobalPipes(new ValidationPipe());
```

在 postman 里测试下：

![](./images/97e1c6db8352a8e88249457a20561d04.webp )

可以看到，提示的错误也不对了。

因为我们自定义的 exception filter 会拦截所有 HttpException，但是没有对这种情况做支持。

![](./images/01c4eac93216c7b6d3d97387107bc56e.webp )

先不加这个 filter。

这时候响应是这样的：

![](./images/0f53026a6f252c878de3b545d97e8772.webp )

我们对这种情况做下支持：

![](./images/698454548c85487a1cfe0a9e8d15e4b1.webp )

启用自定义的 filter，然后打个断点：

![](./images/db1d1f3fa578f457da55735b2909746f.webp )

再次访问会在断点处断住：

![](./images/6a02dbae09bfaf1bfd5e860d458e5594.webp )

可以看到 ValidationPipe 的 response 格式是这样的。

所以我们可以这样改：

![](./images/3094b6645d0ba865ad2b10ae53b0972f.webp )

```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter, HttpException } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class HelloFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const http = host.switchToHttp();
    const response = http.getResponse<Response>();

    const statusCode = exception.getStatus();

    const res = exception.getResponse() as { message: string[] };
    
    response.status(statusCode).json({
       code: statusCode,
       message: res?.message?.join ? res?.message?.join(',') : exception.message,
       error: 'Bad Request',
       xxx: 111
    })
  }
}
```

如果 response.message 是个数组，就返回 join 的结果，否则还是返回 exception.message

再试下：

![](./images/77c1c11bb8b6b95300e3aef65faa04fd.webp )

![](./images/c4c0fc4d7347f51014d9f5d9fe685284.webp )

现在，ValidationPipe 的错误和其他的错误就都返回了正确的格式。

那如果我想在 Filter 里注入 AppService 呢？

这就需要改一下注册方式：

![](./images/7e6239470fc1a1d67b083556370404ca.webp )

不用 useGlobalFilters 注册了，而是在 AppModule 里注册一个 token 为 APP_FILTER 的 provider：

![](./images/ff8f1e3ea0881f60953cb01f5227f497.webp )

```javascript
{
  provide: APP_FILTER,
  useClass: HelloFilter
}
```
Nest 会把所有 token 为 APP_FILTER 的 provider 注册为全局 Exception Filter。

注册多个 Filter 也是这么写。

其余的全局 Guard、Interceptor、Pipe 也是这样注册：

![](./images/ea493babcb4d3f29d7cae5deccec3175.webp )

这样注册的好处就是可以注入其他 provider 了：

比如我注入了 AppService，然后调用它的 getHello 方法：

![](./images/de2e05f43867f6496d3d47add3e887d0.webp )

```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter, HttpException, Inject } from '@nestjs/common';
import { Response } from 'express';
import { AppService } from './app.service';

@Catch(HttpException)
export class HelloFilter implements ExceptionFilter {

  @Inject(AppService)
  private service: AppService;

  catch(exception: HttpException, host: ArgumentsHost) {
    const http = host.switchToHttp();
    const response = http.getResponse<Response>();

    const statusCode = exception.getStatus();

    const res = exception.getResponse() as { message: string[] };
    
    response.status(statusCode).json({
       code: statusCode,
       message: res?.message?.join ? res?.message?.join(',') : exception.message,
       error: 'Bad Request',
       xxx: 111,
       yyy: this.service.getHello()
    })
  }
}
```
可以看到，service 方法调用成功了：

![](./images/ad7d490d312a9490ef67eba969874133.webp )

此外，如果你想自定义 Exception 也是可以的。

比如添加一个 src/unlogin.filter.ts 

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

export class UnLoginException{
  message: string;

  constructor(message?){
    this.message = message;
  }
}

@Catch(UnLoginException)
export class UnloginFilter implements ExceptionFilter {
  catch(exception: UnLoginException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();

    response.status(HttpStatus.UNAUTHORIZED).json({
      code: HttpStatus.UNAUTHORIZED,
      message: 'fail',
      data: exception.message || '用户未登录'
    }).end();
  }
}
```
我们创建了一个 UnloginException 的异常。

然后在 ExceptionFilter 里 @Catch 了它。

在 AppModule 里注册这个全局 Filter：

![](./images/7b96f4a5e2c8d757498c0aebd250f8e2.webp )

```javascript
{
  provide: APP_FILTER,
  useClass: UnloginFilter
}
```
之后在 AppController 里抛出这个异常：

![](./images/670671682c78c394abb351f53e1fc917.webp )

浏览器里访问下：

![](./images/f324cd68cc58438c43cae682aa3e79ac.webp )

可以看到，返回的是我们自定义的格式。

也就是说，可以用自定义 Exception Filter 捕获内置的或者自定义的 Exception。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/exception-filter-test)。
## 总结

这节我们学习了自定义 Exception Filter。

通过 @Catch 指定要捕获的异常，然后在 catch 方法里拿到异常信息，返回对应的响应。

如果捕获的是 HttpException，要注意兼容下 ValidationPipe 的错误格式的处理。

filter 可以通过 @UseFilters 加在 handler 或者 controller 上，也可以在 main.ts 用 app.useGlobalFilters 全局启用。

如果 filter 要注入其他 provider，就要通过 AppModule 里注册一个 token 为 APP_FILTER 的 provider 的方式。

此外，捕获的 Exception 也是可以自定义的。

这样，我们就可以自定义异常和异常返回的响应格式了。