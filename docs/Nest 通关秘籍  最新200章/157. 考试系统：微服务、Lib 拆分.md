# 157. 考试系统：微服务、Lib 拆分

这节我们来做下微服务的拆分，并把一些公共 Module 放到 Lib 里。

创建项目：

```
nest new exam-system
```

![](./images/4f88ca674bcee9e821c5a7979f064f77.webp )

然后添加 4 个 app：

```
nest g app user
```

![](./images/7cea16e85925b1f7af8eae4c2d74338e.webp )

```
nest g app exam
```

![](./images/3f70df562a7b6d2ac39d9a65c556445e.webp )

```
nest g app answer
```

![](./images/775ebae1594c6ee614a6249f8cdbf7c3.webp )

```
nest g app analyse
```

![](./images/8f54aac41678cdf077b93d1ac11af15e.webp )

看下现在的目录：

![](./images/501a7fc1ea38dcbbb5a1cd8ede7f4e64.webp )

还有 nest-cli.json

![](./images/2e5e44c04b6029956270fe10063b2e4e.webp )

我们改下 user、exam、answer、analyse 的服务的启动端口，分别改为 3001、3002、3003、3004

![](./images/d7a3a6b10da199cf049a4e6f14e85e41.webp )

![](./images/c2a565b58ce82366baa508f72a9712b7.webp )

![](./images/5acd4b534d9f2bbab27dbc7e0367ab25.webp )

![](./images/7a1ee15431c9dbb4812298fad7847e17.webp )

跑起来：

```
npm run start:dev user
npm run start:dev exam
npm run start:dev answer
npm run start:dev analyse
```
![](./images/b89892c5f2301e0a906371bd7159574d.gif )

浏览器访问这 4 个服务的接口：

![](./images/370ac4488463cb1265fecc3ea54bef67.webp )

![](./images/34aa4091d2b6fc3400307e97f8f3d832.webp )

![](./images/3a0b979aebdad867f94c727fd8547c89.webp )

![](./images/6e9d61ae3e0093f23d1f810421adcad4.webp )

没啥问题。

多个微服务之间是可以相互调用的。

在根目录安装微服务的包：

```
npm install @nestjs/microservices --save
```
然后改下 exam 微服务，添加一个消息处理函数：

![](./images/ed88a6391d7883322bbdfc10267613e2.webp )

```javascript
@MessagePattern('sum')
sum(numArr: Array<number>): number {
    return numArr.reduce((total, item) => total + item, 0);
}
```
在 main.ts 里注册下：

![](./images/deded893bc740b15928bcfa573dbc342.webp )

```javascript
app.connectMicroservice({
    transport: Transport.TCP,
    options: {
      port: 8888,
    },
});
app.startAllMicroservices();
```
exam 服务暴露了 3002 的 HTTP 服务，现在用 connectMicroservice 就是再暴露 8888 的 TCP 服务。

在 answer 的服务里面调用下这个微服务：

![](./images/6023554b170868f6f63594b123fe92b4.webp )
```javascript
ClientsModule.register([
  {
    name: 'EXAM_SERVICE',
    transport: Transport.TCP,
    options: {
      port: 8888,
    },
  },
])
```
用客户端模块连接上 888 端口的微服务，然后在 Controller 里调用下：

![](./images/18b78ca659e0f9f2a066be99b7cd8532.webp )

```javascript
import { Controller, Get, Inject } from '@nestjs/common';
import { AnswerService } from './answer.service';
import { ClientProxy } from '@nestjs/microservices';
import { firstValueFrom } from 'rxjs';

@Controller()
export class AnswerController {
  constructor(private readonly answerService: AnswerService) {}

  @Inject('EXAM_SERVICE')
  private examClient: ClientProxy

  @Get()
  async getHello() {
    const value = await firstValueFrom(this.examClient.send('sum', [1, 3, 5]));
    return this.answerService.getHello() + ' ' + value
  }
}
```
在之前的 hello world 接口里调用下微服务的 sum 方法。

用 firstValueFrom 取返回的值。

重新跑一下这两个服务：

```
npm run start:dev exam
npm run start:dev answer
```
试一下：

![](./images/40da35a65cfc9b458c335c68925bcc30.webp )

微服务调用成功了。

虽然是隔着网络的两个服务，但是用起来和本地的 service 体验一样，这就是 RPC（远程过程调用）

user、exam、answer、analyse 微服务，各自提供 HTTP 接口，之间还可以通过 TCP 做相互调用。

那多个微服务的公共代码呢？

放在 lib 里。

比如 RedisModule：

```
nest g lib redis
```
![](./images/cb045bf418b0818a9b97ce8aba8be8f9.webp )

会让你指定一个前缀，这里用默认的 @app。

然后可以看到在 libs 目录下多了这个公共模块：

![](./images/7c19e39f7b53aa9e8ede5da2a3610a10.webp )

并且在 tsconfig.json 里生成了别名配置：

![](./images/c509974b75331c953cc88c16c9f71cbe.webp )

改下 RedisModule

```javascript
import { Global, Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [RedisService, 
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```
还有 RedisService

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType

    async keys(pattern: string) {
        return await this.redisClient.keys(pattern);
    }

    async get(key: string) {
        return await this.redisClient.get(key);
    }

    async set(key: string, value: string | number, ttl?: number) {
        await this.redisClient.set(key, value);

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```
然后分别在 user 和 exam 的 service 里用一下：

![](./images/c271e65679952410e73aaa333888f0f3.webp )

![](./images/30e85e0157fc3779f0951e61f94d5b81.webp )

```javascript
import { Controller, Get, Inject } from '@nestjs/common';
import { UserService } from './user.service';
import { RedisService } from '@app/redis';

@Controller()
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Inject(RedisService)
  redisService: RedisService;

  @Get()
  async getHello() {
    const keys = await this.redisService.keys('*');
    return this.userService.getHello() +  keys;
  }
}
```
把 redis 的容器跑起来，去 RedisInsight 里看下：

![](./images/6eeb5d156a116590f5f4fd6dbb46a4b2.webp )

有两个 key。

把用户微服务跑起来：

```
npm run start:dev user
```
访问下：

![](./images/d3fb3250ae7ad28552c1b9ef3a10203f.webp )

可以看到，lib 里的 RedisService 正确引入并生效了。

在 exam 微服务里也引入下：

![](./images/3010f0d709a3f15ed2213ae78f4bf7c6.webp )

![](./images/b64fb64e477322088efcf0231d0b1f13.webp )

```javascript
@Inject(RedisService)
redisService: RedisService;

@Get()
async getHello() {
    const keys = await this.redisService.keys('*');
    return this.examService.getHello() +  keys;
}
```
把服务跑起来：

```
npm run start:dev exam
```
试一下：

![](./images/b826cacf8b639ffe06a23d69efe77170.webp )

这样，同一个模块就可以在两个微服务里使用了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/exam-system)

## 总结

这节我们微服务架构的项目结构。

创建了 user、exam、answer、analyse 这 4 个 app，还有 redis 这个公共 lib。

4 个微服务都单独暴露 http 接口在不同端口，之间还可以通过 TCP 来做通信。

微服务之间的 RPC 通信用起来就和用本地的 service 一样。

libs 下的模块可以在每个 app 里引入，可以放一些公共代码。

这样，微服务架构的 monorepo 的项目就够就搭建完成了。

