# 133. 会议室预定系统：Google 账号登录后端开发

我们的网站实现了用户名密码登录，用户忘记了密码也可以通过邮箱验证码来修改密码，之后再登录。

![](./images/27fea37176a771022d7b2a2a853baedb.webp )

![](./images/d2e084a68fe17e4455528310b5dab9b9.webp )

这样功能上没问题，但是不方便。

用户会访问很多个网站，如果每个网站都需要注册一个账号，那对于不常用的网站，很容易忘记账号密码。

解决方式就是支持三方账号登录。

比如 [dockerhub 的登录](https://login.docker.com/u/login)：

![](./images/593d1590974bc8a415431175d9dd44c6.webp )

你可以登录 google、github 账号，然后授权，这样 dockerhub 网站就可以自动登录了。

根本不需要单独的账号密码。

原理就是他用你 github、google 的信息来给你创建了一个账号，之后只要是同样的 github、google 信息就可以自动登录了。

当你第一次授权的时候：

![](./images/53f6052c1996561b6a39276b2a4c9654.gif )

会跳到这个页面：

![](./images/6f36ecf3637bdec961a55dd843b94bd0.webp )

因为缺少了 username 的信息，你填上之后就可以注册了。

并且它还自动给你登录了：

![](./images/e764d9423b85bd915200cd05b512066b.webp )

然后退出登录用 google 账号登录一次：

![](./images/48ea3e59b59f02b47bc8411205018fcc.gif )

因为你授权过，短时间内不需要再次授权，于是就直接登录了。

感受下现在的登录体验。

需要记住用户名密码么？

不需要。

你只需要点下 google 登录，然后授权，就自动登录了。

我们也在会议室预定系统里集成下 google 登录。

会用到 passport-google 的策略来做三方登录，所以要集成 passport。

进入 backend 项目，安装 passport 的包：

```
npm install --save @nestjs/passport passport
```
安装用户名密码认证的 passport-local 策略包：

```
npm install --save passport-local
npm install --save-dev @types/passport-local
```
然后创建一个认证模块：

```
nest g module auth
```
![](./images/5476a34c05789879bb2263cf50e6c325.webp )

添加用户名密码认证的策略 auth/local.strategy.ts

```javascript
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {

  async validate(username: string, password: string) {
    
  }
}
```

这里需要用到 UserService，在 UserModule 导出一下：

![](./images/35604feef9a145f2de1d88bf2767f140.webp )

然后 AuthModule 引入 UserModule：

![](./images/d7cba9c6835ba86cca2b987931c3f423.webp )

并把 LocalStrategy 声明为 provider。

LocalStrategy 里直接复用 userService.login 来做登录认证：

![](./images/44511f3d0b9ae8eb81730351fb889138.webp )

passport 会把返回的 user 信息放在 request.user 上。

然后 user/login 里就不需要手动调用 userService 了：

![](./images/c0225fe27771cb23f82e8243c7d4d57c.webp )

改成这样，用 AuthGuard('local') 来做处理即可，处理完从 reqeust.user 里拿 user 信息：

![](./images/2ace327cf3156caa4c4ab521f68965d5.webp )

把服务跑起来：

```
npm run start:dev
```

![](./images/4f0e58c4e0d661032fed415e6a3272e2.webp )

然后进入 frontend_user 也把开发服务跑起来：

```
npm run start
```

当用户不存在：

![](./images/4180540179baea8f5cb88206f00f11ca.webp )

当密码错误：

![](./images/d88e4e124c221cdd19a8f082a558f944.webp )

用户名密码都正确时：

![](./images/22412fcdc0cd3c243cb9b3fa166e58e8.gif )

没啥问题。

这样，我们的 passport 就集成成功了。

当然，passport-local、passport-jwt 都不集成也可以，直接用 passport-google 和 passport-github 就行。

各个策略都是独立的，可以单独使用。

下面我们来实现 google 和 github 登录：

上节我们实现了 Github 登录，这节继续来实现下 Google 登录。

在 [passport 的网站](https://www.passportjs.org/packages/)搜索：

![](./images/c5385f9be7b39dd5c9377b0f1f9c515f.webp )

找下载量最多的那个。

然后安装下：

```
npm install --save passport-google-oauth20
npm install --save-dev @types/passport-google-oauth20
```

获取 client id 和 client secret 的步骤[前面章节](https://juejin.cn/book/7226988578700525605/section/7376480527337193482)讲过。

授权的域名、callback url 要和应用中的对应才行，否则就重新搞一个。

我这里重新注册了一个应用，拿到了 client id：

![](./images/04f6ef2a1b165a62001bb184490e8cc2.webp )

![](./images/f1fa25059b121279851d753b6f2cfa63.webp )

创建 auth/google.strategy.ts

```javascript
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-google-oauth20';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor() {
    super({
      clientID: '535538293892-fso0juek6ag5eupus679gnrgt3g5gknq.apps.googleusercontent.com',
      clientSecret: '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',
      callbackURL: 'http://localhost:3005/user/callback/google',
      scope: ['email', 'profile'],
    });
  }

  validate (accessToken: string, refreshToken: string, profile: any) {
    const { name, emails, photos } = profile
    const user = {
      email: emails[0].value,
      firstName: name.givenName,
      lastName: name.familyName,
      picture: photos[0].value,
      accessToken
    }
    return user;
  }
}
```
这里填入刚刚的 clientID、clientSecret、callbackURL。

在 AuthModule 引入：

![](./images/b7e2506ac95fd89d71dd5892bfe06a7c.webp )

之后在 UserController 添加两个路由：

![](./images/3711a650e168358cc6c5586d2235eada.webp )

```javascript
@Get('google')
@UseGuards(AuthGuard('google'))
async googleAuth() {}

@Get('callback/google')
@UseGuards(AuthGuard('google'))
googleAuthRedirect(@Req() req) {
    if (!req.user) {
      return 'No user from google'
    }

    return {
      message: 'User information from google',
      user: req.user
    }
}
```
一个是触发登录的，一个是回调的。

测试下：

![](./images/2453dc1d01c8b79408b5f9e7aae4de05.gif )

可以看到，google 的用户信息拿到了：

![](./images/3b7ae375d9a92f5bf94f031069336adb.webp )

那我们只要在拿到用户信息的时候自动注册下就好了。

在 user.entity.ts 添加 loginType 字段：

![](./images/116e096927a439ae71397c63502f3180.webp )

```javascript
@Column({
    type: 'int',
    comment: '登录类型, 0 用户名密码登录, 1 Google 登录, 2 Github 登录',
    default: 0
})
loginType: LoginType;
```

```javascript
export enum LoginType {
    USERNAME_PASSWORD = 0,
    GOOGLE = 1,
    GITHUB = 2
}
```
默认是用户名密码登录，值是 0，当 google 或者 github 登录时，loginType 是 1 和 2。

因为前几节我们把 synchronize 关掉了，所以现在并不会自动创建这一列：

![](./images/c498778b7811fcb7daf064ec42cb049a.webp )

我们通过 migration:generate 生成个迁移：

```
npm run migration:generate src/migrations/add-user-loginType-column
```
![](./images/9f824c95b0a95373399228c529778b1f.webp )

生成的迁移类没问题：

![](./images/4a3faa4309ce9a44d28b429254244529.webp )

跑一下：

```
npm run migration:run
```

![](./images/30ef7f3be8457811f78fe910bb9c38d3.webp )

在数据库看一下：

![](./images/e8d09a7fe27ed9f572d968cfea8c51ba.webp )

![](./images/282d97ddd931bec3cc37fb1babfa0db7.webp )

loginType 列添加成功了。

![](./images/e15eb66edc8c2c34587bdfc0e357f914.webp )

migrations 表也记录了这条执行记录。

然后补充下 google 授权后自动注册的逻辑：

在 UserService 里添加 registerByGoogleInfo 方法：

![](./images/2e15159ecbed96c98ef31f4503d29cb0.webp )

```javascript
async registerByGoogleInfo(email: string, nickName: string, headPic: string) {
    const newUser = new User();
    newUser.email = email;
    newUser.nickName = nickName;
    newUser.headPic = headPic;
    newUser.password = '';
    newUser.username = email + Math.random().toString().slice(2, 10);
    newUser.loginType = LoginType.GOOGLE;
    newUser.isAdmin = false;

    return this.userRepository.save(newUser);
}
```

email、nickName、headPic 都是基于 google 返回的信息。

![](./images/486bdc07d38f47875f6b9a02e373e2e2.webp )

username 我们就用 email + 随机数的方式生成，反正也不需要用用户名密码登录，保证唯一就行。

passport 也是一样。

在 UserController 调用下：

```javascript
@Get('callback/google')
@UseGuards(AuthGuard('google'))
async googleAuthRedirect(@Req() req) {
  if (!req.user) {
    throw new BadRequestException('google 登录失败');
  }
  const user = await this.userService.registerByGoogleInfo(
    req.user.email, 
    req.user.firstName + ' ' + req.user.lastName,
    req.user.picture
  );

  const vo = new LoginUserVo();
  vo.userInfo = {
      id: user.id,
      username: user.username,
      nickName: user.nickName,
      email: user.email,
      phoneNumber: user.phoneNumber,
      headPic: user.headPic,
      createTime: user.createTime.getTime(),
      isFrozen: user.isFrozen,
      isAdmin: user.isAdmin,
      roles: [],
      permissions: []
  }

  vo.accessToken = this.jwtService.sign({
    userId: vo.userInfo.id,
    username: vo.userInfo.username,
    email: vo.userInfo.email,
    roles: vo.userInfo.roles,
    permissions: vo.userInfo.permissions
  }, {
    expiresIn: this.configService.get('jwt_access_token_expires_time') || '30m'
  });

  vo.refreshToken = this.jwtService.sign({
    userId: vo.userInfo.id
  }, {
    expiresIn: this.configService.get('jwt_refresh_token_expres_time') || '7d'
  });

  return vo;
}
```
就是用 google 返回的信息来自动注册，并且自动登录，返回 accessToken 和 refreshToken。

测试下：

![](./images/a1a3066a6598507f05091585e466bb5e.gif )

可以看到，google 授权之后，自动注册并返回了 token 信息，这样带上这个访问就是登录状态了：

![](./images/1bca681e79b1d33c08ef6306679dfda2.webp )

数据库里 user 表也插入了该用户的记录：

![](./images/14fd2ac73c9774b4e307143d961f62c6.webp )

nickName、headPic、username、loginType 都是对的。

后续 refreshToken 的流程不受影响，因为它只是取出 jwt 里的 userId 来查询用户信息并重新生成 token 返回：

![](./images/9945e32c5dd4baf137f2146a3e34ff99.webp )

然后继续处理 google 登录：

google 第一次账号授权会自动注册并登录，但是后续就不需要注册了。

所以我们要加个判断：

![](./images/cd0e2689252873786342ea58b96caa7e.webp )

如果 email 能查到用户，那就直接登录：

```javascript
@Get('callback/google')
@UseGuards(AuthGuard('google'))
async googleAuthRedirect(@Req() req) {
  if (!req.user) {
    throw new BadRequestException('google 登录失败');
  }

  const foundUser = await this.userService.findUserByEmail(req.user.email);

  if(foundUser) {
    const vo = new LoginUserVo();
    vo.userInfo = {
        id: foundUser.id,
        username: foundUser.username,
        nickName: foundUser.nickName,
        email: foundUser.email,
        phoneNumber: foundUser.phoneNumber,
        headPic: foundUser.headPic,
        createTime: foundUser.createTime.getTime(),
        isFrozen: foundUser.isFrozen,
        isAdmin: foundUser.isAdmin,
        roles: foundUser.roles.map(item => item.name),
        permissions: foundUser.roles.reduce((arr, item) => {
            item.permissions.forEach(permission => {
                if(arr.indexOf(permission) === -1) {
                    arr.push(permission);
                }
            })
            return arr;
        }, [])
    }
    vo.accessToken = this.jwtService.sign({
      userId: vo.userInfo.id,
      username: vo.userInfo.username,
      email: vo.userInfo.email,
      roles: vo.userInfo.roles,
      permissions: vo.userInfo.permissions
    }, {
      expiresIn: this.configService.get('jwt_access_token_expires_time') || '30m'
    });

    vo.refreshToken = this.jwtService.sign({
      userId: vo.userInfo.id
    }, {
      expiresIn: this.configService.get('jwt_refresh_token_expres_time') || '7d'
    });
  
    return vo;
  } else {
    const user = await this.userService.registerByGoogleInfo(
      req.user.email, 
      req.user.firstName + ' ' + req.user.lastName,
      req.user.picture
    );

    const vo = new LoginUserVo();
    vo.userInfo = {
        id: user.id,
        username: user.username,
        nickName: user.nickName,
        email: user.email,
        phoneNumber: user.phoneNumber,
        headPic: user.headPic,
        createTime: user.createTime.getTime(),
        isFrozen: user.isFrozen,
        isAdmin: user.isAdmin,
        roles: [],
        permissions: []
    }

    vo.accessToken = this.jwtService.sign({
      userId: vo.userInfo.id,
      username: vo.userInfo.username,
      email: vo.userInfo.email,
      roles: vo.userInfo.roles,
      permissions: vo.userInfo.permissions
    }, {
      expiresIn: this.configService.get('jwt_access_token_expires_time') || '30m'
    });

    vo.refreshToken = this.jwtService.sign({
      userId: vo.userInfo.id
    }, {
      expiresIn: this.configService.get('jwt_refresh_token_expres_time') || '7d'
    });
  
    return vo;
  }
}
```
在 UserService 实现 findUserByEmail 方法：

```javascript
async findUserByEmail(email: string) {
    const user =  await this.userRepository.findOne({
        where: {
            email: email,
            isAdmin: false,
        },
        relations: [ 'roles', 'roles.permissions']
    });

    return user;
}
```

测试下：

![](./images/69a0976b3912dba42212da204669c50d.gif )

数据库已经注册了这个 google 账号对应的 user，再次授权，会查询注册的用户信息返回。

可以看到，只执行了 select 语句：

![](./images/2fc1b4d44b4205c259b050977f498568.webp )

但网站登录后一般都会重定向到首页：

![](./images/222c35eebfc68dab375209b0dd2f3bbb.gif )

这时候一般都是用 cookie 返回 token 的，比如 https://hub.docker.com 就是这么做的：

![](./images/d523a8a0a209f2e18e6043f1c20a083d.webp )

可以看到，它并不是直接返回 jwt 的 token，而是重定向回首页，在 cookie 里携带 token。

前端只要判断下如果 cookie 里有这些 token 就自动登录就好了。

我们也处理下：

操作 cookie 需要用到 cookie-parser 中间件：

```
npm install --save cookie-parser

npm install --save-dev @types/cookie-parser
```
在 main.ts 启用下：

![](./images/1570ee574d0cc7add8b358fcdbc6deb5.webp )

在 callback/google 里注入 Response，设置 cookie：

![](./images/5fd3a014c79da88ea48063807bb7ff2e.webp )

然后重定向：

![](./images/4ffe31852de095c809719c26b02d891f.webp )

试一下：

![](./images/82cb8520821911945dea1284abe6a4da.gif )

重定向没问题。

cookie 也没问题：

![](./images/b57d150afc4ea7c8adbcdf8949709ab5.webp )

![](./images/363cffb465e0c0471d3bb0b91f761738.webp )

此外，我们还要处理下普通的登录，用户名密码登录的时候要过滤下 loginType：

![](./images/e5ba15444319ab19ec4cf8f0d1ad93fe.webp )

google 登录的账号是不能通过用户名密码登录的。

这样，google 登录的后端部分就完成了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)

## 总结

我们的应用之前只支持用户名密码登录，今天实现了 google 登录的后端部分。

首先我们把用户名密码的身份认证改成了用 passport。

当然，这不是必须的，每个策略都是可以独立用的。

然后我们创建了新的 google 应用，拿到 client id 和 client secret。

用 passport-google-oauth20 的策略来实现了 google 登录。

在 callback 的路由里，基于 google 返回的信息做了自动注册，如果用户已经注册过，就直接返回登录信息。

google 登录的 callback 里重定向到网站首页，然后通过 cookie 携带 userInfo、accessToken、refreshToken 等信息。

前端代码再处理下 cookie，同步登录状态就好了。
