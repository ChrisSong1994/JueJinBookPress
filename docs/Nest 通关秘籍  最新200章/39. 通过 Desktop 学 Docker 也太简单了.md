# 39. 通过 Desktop 学 Docker 也太简单了

后端系统会部署很多服务，包括我们自己开发的服务，还有 mysql、redis 等中间件的服务，部署它们需要一系列依赖的安装、环境变量的设置等等。

如果你要部署多台机器的话，同样的操作要重复多次，万一哪一步漏掉了，服务就跑不起来了。

就很麻烦。

而 Docker 就能完美解决这个问题：

它把系统的所有文件封装成一个镜像，镜像跑起来作为容器，它可以在一台机器上跑多个容器，每个容器都有独立的操作系统环境，比如文件系统、网络端口等，在容器内跑各种服务。

这样整个环境都保存在这个镜像里，部署多个实例只要通过这个镜像跑多个容器就行。

![](./images/80c013d88a4f6e15cfa5fdebfd3ed352.webp )

这也是为什么它的 logo 是这样的：

![](./images/8905960c5d3c9019b058b8aad8c5ae7a.webp )

Docker 提供了 Docker Hub 镜像仓库，可以把本地镜像 push 到仓库或者从仓库 pull 镜像到本地。

![](./images/08046e21e34eb76788e237f59ac40189.webp )

我们 pull 个镜像下来试试看：

首先需要安装 Docker，直接从[官网](https://docker.com)下载 docker desktop 就行：

（windows 选择 widnows 的安装包。m1 要注意芯片类型，选择 apple chip 那个包）

![](./images/51e7b9f843f53291d48461ab1c61f71b.webp )

它内置了 docker 命令。

把它安装到系统之后，可以在命令行看下 docker 命令是否可用：

![](./images/930b873c2e23309bff7c42683602c855.webp )

![](./images/36de4c13a0f2edd708fa4801a2370dc3.webp )

如果不可用，那要设置下这个：

![](./images/73188f0ee41c82cb8b632c704844fb23.webp )

点击 Settings > Advanced，里面有两种安装路径，如果是 /usr/local/bin，那 docker 命令就是直接可用的，因为这个路径在 PATH 变量里。

如果是第二种，那就需要手动把它加到 PATH 环境变量里。

然后我们来看看 docker desktop 的界面：

![](./images/75851a0e862ad2966e5b4555b2d1ac5d.webp )

![](./images/7e1fbb36c29f7b217dcb77400d1ed765.webp )

images 是本地的所有镜像，containers 是镜像跑起来的容器。

docker desktop 可以可视化的管理它们，很方便。

我们 pull 一个镜像试试看。

![](./images/8b7699170dff96eff8b7dfe0ce1514b7.webp )

搜索 nginx 镜像，点击 pull（搜索这步需要翻墙，不然搜不到）。

pull 下来之后，就可以在本地 images 看到了：

![](./images/21c2c48a30706450ccad8749d950d6c3.webp )

如果搜不到，那直接在命令行用 docker search、docker pull 搜索和拉取镜像也可以：

![](./images/072cd347adaf9376c002ad859b27ce43.webp )

点击 run 会让你填一些参数：

![](./images/5f4ffb7b28f492e5585c97c3db50e15b.webp )

首先是名字，如果不填，docker desktop 会给你生成随机的容器名字。

就是这种：

![](./images/4f1bd0c8955dca87ec335fd53a836c4d.webp )

然后是端口，容器内跑的 nginx 服务是在 80 端口，你要把宿主机的某个端口映射到容器的 80 端口才可以访问。

接下来是数据卷 volume，这个是把宿主机某个目录挂到容器内。

因为容器是镜像跑起来的，下次再用这个镜像跑的还是同样的容器，那你在容器内保存的数据就会消失。

所以我们都是把某个宿主机目录，挂载到容器内的某个保存数据的目录，这样数据是保存在宿主机的，下次再用镜像跑一个新容器，只要把这个目录挂载上去就行。

至于环境变量，这个就很容易理解了。

我们分别设置一下：

![](./images/6d30d61db121509efcb610738e5af45b.webp )

挂载本地的 /tmp/aaa 到容器内的 /usr/share/nginx/html 目录。

这里的 /tmp/aaa 可以换成宿主机的任何目录，如果是 windows 系统，那就是类似 D://tmp/aaa 这种。

**（注意，这里是 /usr 而不是 /user）**

点击 run：

![](./images/ea5d2171dbf303c91609255d1c8828e8.webp )

可以看到容器内的 nginx 服务跑起来了。

我们在 /tmp/aaa 目录下添加一个 index.html:

![](./images/2271a0a4346f91e34229a6653cebdbef.webp )

浏览器访问 <http://localhost> 就可以访问到：

![](./images/ba0a94359aa7bc6922cd63870799f5b0.webp )

这就说明数据卷挂载成功了。

点击 files 标签就可以看到容器内的文件。

可以看到 /usr/share/nginx/html 被标识为 mounted，就是挂载目录的意思：

![](./images/8890ee83095c08346ec78f334ec948e7.webp )

我们再在本地添加一个文件：

![](./images/4027ab0294c6175d76c7cb33bef316ec.webp )

你会发现容器内这个目录内容也变了：

![](./images/7a4715ad3439078fe0727f3e7720436a.webp )

这就是 volume 挂载的作用。

如果你挂载某些目录报错，是因为 docker desktop 挂载的目录是需要配置的，在 Settings > Resources > File Sharing 里加一下就行：

![](./images/4382f23a0f11223238601e9315ab0052.webp )

至于挂载到的目录，在镜像搜索结果页有写：

![](./images/fd263f570a7aab72b6928f127a6d3c28.webp )

通过命令行  docker run 来跑镜像， -v 是指定挂载的数据卷，后面的 :ro 代表 readonly，也就是容器内这个目录只读，:rw 表示容器内可以读写这个目录。

这就是数据卷的作用。

此外，你还可以进入到容器内执行各种命令：

![](./images/2b687e89bd1f164436742e201ddaa086.webp )

是不是感觉 docker 学起来还挺简单的？

docker 常用的就是这些东西。

当然，在服务器上没有 Docker Desktop 这种东西，还是要敲命令的。

比如我们点击 pull 按钮，就相当于执行了 docker pull：

    docker pull nginx:latest

latest 是标签，也就是这个：

![](./images/4d68a9a8f07e7b84fc1666bf0b1f7bb0.webp )

然后我们点击 run 按钮，填了个表单，就相当于执行了 docker run：

    docker run --name nginx-test2 -p 80:80 -v /tmp/aaa:/usr/share/nginx/html -e KEY1=VALUE1 -d nginx:latest 

\-p 是端口映射

\-v 是指定数据卷挂载目录

\-e 是指定环境变量

\-d 是后台运行

对照下前面可视化界面，是不是瞬间就懂了：

![](./images/9520177d5fbcaf4dd4840ca756c3d2d1.webp )

docker run 会返回一个容器的 hash：

![](./images/a588631bebb2355eff55f3c426becd16.webp )

就是这里的 id：

![](./images/69bc54ece7aa9c713b6a9afb672aeacf.webp )

这个界面可以用 docker ps 来获取：

![](./images/86a22e7e4f0a2bb2ad61d0e0141ec6fa.webp )

它是显示容器列表的，默认是运行中的。

想显示全部的，可以加个 -a

![](./images/d185da917808a57fd6a9393879ded1ea.webp )

除了 container 列表，image 镜像列表也可以通过 docker images 命令获取：

![](./images/b8f8ad89c1b6b4406e6caba139d252cd.webp )

我们在容器的 terminal 里执行命令，对应的是  docker exec 命令：

![](./images/ebc7e18f103b39c7642f8130efa4b373.webp )

![](./images/6ff4a5247314ec2aa99a5810ed34738f.webp )

\-i 是 terminal 交互的方式运行

\-t 是 tty 终端类型

然后指定容器 id 和 shell 类型，就可以交互的方式在容器内执行命令了。

查看日志，对应 docker logs 命令：

![](./images/eb3333ada957390200e7f2c2a23a4b00.webp )

![](./images/3457478037e2fe736214f867b172279e.webp )

输入 exit 退出：

![](./images/a2639689e008a53dbb28876695e9ffcf.webp )

docker inspect 可以查看容器的详情

![](./images/e97c4e96cfff389ea88f85795acf0d05.webp )

对应 desktop 里的 inspect 的 tab：

![](./images/1dc2021d6cc6c9dfcbc8902df2fa4565.webp )

docker volume 可以管理数据卷：

![](./images/beaade68d778ebb59d8c9795e9123867.webp )

对应 desktop 的这部分：

![](./images/a374be21357f31f83ddd82845fd00926.webp )

此外，还有这些常用命令：

*   docker start：启动一个已经停止的容器
*   docker rm：删除一个容器
*   docker stop：停止一个容器

都可以通过 docker desktop 很方便的操作

## 总结

Docker 可以把环境封装成镜像，镜像跑起来是一个独立的容器。通过这种方式可以快速部署多个相同的实例。

docker 提供了一个 desktop 工具，可以可视化的操作 docker，包括容器、镜像、volume 等

我们 pull 了一个 nginx 镜像下来，指定端口映射、挂载的数据卷，并把它跑起来了。

这就是 docker 的基本用法。

当然，这些可视化的操作都有对应的命令，当服务器上没有桌面的时候，就需要用命令行操作了。

不得不说，用 desktop 来学 docker 真是太简单了。
