# 83. 用 Swagger 自动生成 api 文档

后端开发完接口后，需要给前端一份接口文档，描述有哪些接口，是 GET 还是 POST，有哪些参数，响应是什么。

但是写完代码后再去单独写一份这样的文档还是很麻烦的，并且改动接口之后也要同步去修改接口文档。

能不能自动生成 API 接口文档呢？

是可以的，就是这节要讲的 swagger。

我们新建个项目：
```
nest new swagger-test -p npm
```
安装 swagger 的包：

```
npm install --save @nestjs/swagger
```

然后在 main.ts 添加这样一段代码：

![](./images/5f87246c5fd6e765039660b68cca04d3.webp )

```javascript
const config = new DocumentBuilder()
    .setTitle('Test example')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('test')
    .build();
const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('doc', app, document);
```
通过 DocumentBuilder 创建 config。

然后用 SwaggerModule.createDocument 根据 config 创建文档。

之后用 SwaggerModule.setup 指定在哪个路径可以访问文档。

跑起来试试：

```
npm run start:dev
```
访问 http://localhost:3000/doc 就可以看到 swagger 的 api 文档了：

![](./images/334ff1c7942340bc777bf4cda69d4bc1.webp )

和 DocumentBuilder 填的配置的对应关系如下：

![](./images/c3838574ed82df961507125d913c7c4f.webp )

现在只有一个接口，调用会返回 hello world：

![](./images/9f216ed66007827ee20b5c57b061bf27.webp )

点击 try it out，再点击 execute，就可以看到返回的响应体和 header：

![](./images/19e6c40864bd0a1d510ada02c86eabc4.webp )

我们在 AppController 加几个接口试试：

```javascript
@Get('aaa')
aaa(@Query('a1') a1, @Query('a2') a2) {
    console.log(a1, a2);
    return 'aaa success';
}

@Get('bbb/:id')
bbb(@Param('id') id) {
    console.log(id);
    return 'bbb success';
}

@Post('ccc')
ccc(@Body('ccc') ccc) {
    console.log(ccc);
    return 'ccc success';
}
```

加了一个有 query 参数、一个有 param 参数、一个有 body 参数的接口。

刷新下可以看到，这几个接口都列出来了：

![](./images/6162ffd65574052a7550d414245ecdc1.webp )

但是都没有 param 的描述和 response 的描述：

![](./images/8e2913af87d9cab420130d8fe7900eaa.webp )

这时就需要我们手动标注了：

```javascript
@ApiOperation({ summary: '测试 aaa',description: 'aaa 描述' })
@ApiResponse({
    status: HttpStatus.OK,
    description: 'aaa 成功',
    type: String
})
@Get('aaa')
aaa(@Query('a1') a1, @Query('a2') a2) {
    console.log(a1, a2);
    return 'aaa success';
}
```
给 aaa 接口添加 @ApiOperation 和 @ApiResponse 的装饰器。

这俩分别是指定这个接口的描述，接口的响应的。

![](./images/2eb0a91858cad8676d7d86fffaa97ee1.webp )

再加上 @ApiQuery 来添加 query 参数的说明：

![](./images/3b0c6b11d503ff915fc0066c0ac9405a.webp )

```javascript
@ApiQuery({
    name: 'a1',
    type: String,
    description: 'a1 param',
    required: false,
    example: '1111',
})
@ApiQuery({
    name: 'a2',
    type: Number,
    description: 'a2 param',
    required: true,
    example: 2222,
})  
```
刷新下，可以看到 swagger 文档里出现了这两个参数的说明：

![](./images/d3d87ba3edd24fc07ea49b5a79f02c17.webp )

点击 try it out 和 execute，就可以看到发送了请求并返回了响应：

![](./images/2d069b2db9687eef68366604bd5fc943.webp )

这样，一个接口就描述完了：

![](./images/31d001444d0bb9dcae36a76a75969ff5.webp )

通过 @ApiOperation 描述接口的信息，@ApiResponse 描述返回值信息，@ApiQuery 描述 query 参数信息。

就能生成对应的 swagger 文档：

![](./images/34c4add17b1b106b24a24886bf1dbc26.webp )

我们接着来生成 bbb 接口的 swagger 文档：

![](./images/70331dd6b70ddaaa191f3e6a4680ef8d.webp )

这里用到的是 @ApiParam 而不是 @ApiQuery，其余部分一样：
```javascript
@ApiOperation({ summary: '测试 bbb',description: 'bbb 描述' })
@ApiResponse({
    status: HttpStatus.OK,
    description: 'bbb 成功',
    type: String
})
@ApiParam({
    name: 'id',
    description: 'ID',
    required: true,
    example: 222,
})
```
刷新可以看到 bbb 接口的文档：

![](./images/7457bab6c753c2e26e75517805d5c066.webp )

那如果 id 不合法的时候，我返回了一个 401 的响应呢？

那就再加一个 @ApiResponse

![](./images/1ca61d9c5cb5f8fb7fbc2691ff253cfb.webp )

```javascript
@ApiOperation({ summary: '测试 bbb',description: 'bbb 描述' })
@ApiResponse({
    status: HttpStatus.OK,
    description: 'bbb 成功',
    type: String
})
@ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'id 不合法'
})
@ApiParam({
    name: 'id',
    description: 'ID',
    required: true,
    example: 222,
})
@Get('bbb/:id')
bbb(@Param('id') id: number) {
    console.log(id);
    if(id !== 111) {
      throw new UnauthorizedException();
    }
    return 'bbb success';
}
```
刷新下，可以看到 swagger 文档标识出了这两种响应：

![](./images/3b2bc03ee10b34b206dcfb10c023639b.webp )

然后再来写 ccc 接口的文档：

ccc 接收的是请求体的参数，我们创建个 CccDto。

![](./images/c11594ab6426645e1b8389194e1b5f56.webp )

```javascript
export class CccDto {
    aaa: string;
    bbb: number;
    ccc: Array<string>;
}
```
接收参数通过 dto 来接收，而返回值放在 vo 里：

```javascript
@Post('ccc')
ccc(@Body('ccc') ccc: CccDto) {
    console.log(ccc);
    return {
      aaa: 111,
      bbb: 222
    };
}
```
创建个 vo 的 class：

![](./images/a0fac10a34163ba52eb2bf3a1122fcc4.webp )
```javascript
export class CccVo {
    aaa: number;
    bbb: number;
}
```
返回值就可以改成这样了：

```javascript
@Post('ccc')
ccc(@Body('ccc') ccc: CccDto) {
    console.log(ccc);

    const vo = new CccVo();
    vo.aaa = 111;
    vo.bbb = 222;
    return vo;
}
```

这里的 dto、vo 随便搜一下就能查到解释：

![](./images/9881a7e14c178a82ee780306a63c2a6b.webp )

在 Nest 里要能清楚的区分 dto、vo、entity 的区别：

![](./images/78517e7ae44e6eec2836c83262fdd7e3.webp )

dto 是 data transfer object，用于参数的接收。

vo 是 view object，用于返回给视图的数据的封装。

而 entity 是和数据库表对应的实体类。

然后我们继续来写 ccc 接口的 swagger 文档。

很容易想到，body 的描述是通过 @ApiBody 的装饰器：

![](./images/555a595b40ab8b3c5511708f298856be.webp )
```javascript
@ApiOperation({summary:'测试 ccc'})
@ApiResponse({
    status: HttpStatus.OK,
    description: 'ccc 成功',
    type: CccVo
})
@ApiBody({
    type: CccDto
})
@Post('ccc')
ccc(@Body('ccc') ccc: CccDto) {
    console.log(ccc);

    const vo = new CccVo();
    vo.aaa = 111;
    vo.bbb = 222;
    return vo;
}
```

刷新页面，你会看到除了接口外，还生成了俩 schema。

![](./images/54662393102dbd92f0c8116ba598a7c8.webp )

也就是说对象的响应会对应 swagger 的 schema。

只不过现在 CccDto、CccVo 的 schema 没有内容，这是因为我们还没有标注。

在 CccDto 加一下：

![](./images/556210155d43467b88949f29a6d2ccf3.webp )

aaa、bbb、ccc 通过 @ApiProperty 标识下，并且 bbb 是 @ApiPropertyOptional，也就是可选，这个和 @ApiProperty({ required: false }) 等价。

aaa 可以传 enum 的值，取值范围是 a1、a2、a3。

同样，CccVo 也加一下：

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class CccVo {
    @ApiProperty({ name: 'aaa' })
    aaa: number;

    @ApiProperty({ name: 'bbb' })
    bbb: number;
}
```
刷新下，现在就可以看到 CccDto、CccVo 的 schema 有属性了：

![](./images/002e15756ef53f01398d8c181e47c783.webp )

其中 bbb 是没有 * 的，代表可不传。

上面的接口部分也有了请求和响应的示例：

![](./images/b625e35f5cafc66b6013350bb716b755.webp )

点下 try it out，可以自己编辑请求体：

![](./images/a64eb645599a382bc1b031fbc26c4aba.webp )

然后点击 execute 就可以看到响应的内容和 header：

![](./images/f68b33515c1a6dd10818f8095bf660c6.webp )

服务端也确实接收到了这个请求：

![](./images/da4ced86d0ab60f545f62df3905472ba.webp )

可以用 swagger 来方便的测试接口。

此外，还可以通过 @ApiTags 来给接口分组：

![](./images/6aacac777490ec215f506e9562ae7187.webp )

比如 controller 是 xxx 开头的，那可以用 @ApiTags 来分组到 xxx。

显示的时候，就会把这个 controller 的接口分到一个组下：

![](./images/9fe519fd8e5675afff62b273408fa9c0.webp )

也可以添加在 handler 上：

![](./images/5ea6e44ff91fc8bdbea4fa437e2c6d94.webp )

![](./images/e784f8bd02f298d193065a43a4e8e50f.webp )

比如把 aaa、bbb 接口分到 xxx-get 的组。

那显示的时候就会把这俩接口分出来：

![](./images/e6123f8be381eef97a7ddaf85d582f7b.webp )

当接口多了之后，分组还是很有必要的。

回过头来，再讲下 @ApiProperty，其实它还有很多属性：

```javascript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";

export class CccDto {
    @ApiProperty({ name: 'aaa', enum: ['a1', 'a2', 'a3'], maxLength: 30, minLength: 2, required: true})
    aaa: string;

    @ApiPropertyOptional({ name: 'bbb', maximum: 60, minimum: 40, default: 50, example: 55})
    bbb: number;

    @ApiProperty({ name: 'ccc' })
    ccc: Array<string>;
}
```

比如 required、minium、maximum、default、maxLength 等。

![](./images/e7690227c3cfe5b30974ed566e511a60.webp )

此外，很多接口是需要登录才能访问的，那如何限制呢？

swagger 也提供了这方面的支持。

常用的认证方式就是 jwt、cookie。

分别在 aaa、bbb、ccc 接口添加 @ApiBearerAuth、@ApiCookieAuth、@ApiBasicAuth

![](./images/47604dda73e4fa3eee70e408c8746b48.webp )

![](./images/e30b49668601f71669247d46bbe7a7dd.webp )


![](./images/8d30aabff95359d33b16cba81227424f.webp )

然后在 main.ts 里添 3 种认证方式的信息：

![](./images/0691aee3dfe3ff689fd55f3a94e27b00.webp )

```javascript
const config = new DocumentBuilder()
    .setTitle('Test example')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('test')
    .addBasicAuth({
      type: 'http',
      name: 'basic',
      description: '用户名 + 密码'
    })
    .addCookieAuth('sid', {
      type: 'apiKey',
      name: 'cookie',
      description: '基于 cookie 的认证'
    })
    .addBearerAuth({
      type: 'http',
      description: '基于 jwt 的认证',
      name: 'bearer'
    })
    .build();
```
刷新页面就可以看到接口出现了锁的标记：

![](./images/733471f9a1278a3c9f0e4d53ed8e8c10.webp )

点击 aaa 的锁：

![](./images/d1278919712efd87540823224929a2bd.webp )

输入 jwt 的 token，然后点击 authorize。

![](./images/b474196367aea52114d7311e607ae851.webp )

锁会变成锁住状态，代表授权成功了。

这时候再发一个请求：

![](./images/76440f5fe71f1b3634a1c5a7a9a8dc68.webp )

会发现带上了 Authorization 的 header，这就是我们见过的 jwt 认证方式。

同理，下面的 cookie 会带上对应的 cookie来认证：

![](./images/8fb6e9d1e4e880934629e746a3e9156d.webp )

![](./images/1ab73ed06bdbb4c7a4486107ee5d7b16.webp )

而 basic 的方式，会要求你输入用户名密码：

![](./images/df26399ec24939f67fb33eb1ca94ea66.webp )

请求时会带上 Authorization： Basic xxx 的 header 来访问。

![](./images/e8944e2624a1ead2f5f16c56937a6655.webp )

这样，这些需要授权的接口就分别添加上了不同的认证方式的标识。

其实，swagger 是一种叫做 openapi 标准的实现。

在 /doc 后加上个 -json 就可以看到对应的 json

![](./images/c86f274cf8c2dcc7af4609b29e782bc8.webp )

装个格式化 chrome 插件格式化一下，大概是这样的：

![](./images/b26ac0ca7a9492907ffcc2f33198a830.webp )

如果你觉得 swagger 文档比较丑，可以这个 json 导入别的平台。

一般 api 接口的平台都是支持 openapi 的。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/swagger-test)

## 总结

这节我们学习了 swagger 自动生成文档。

需要先安装 @nestjs/swagger 的包。

然后在 main.ts 里用 DocumentBuilder + SwaggerModule.createDocuemnt 创建 swagger 文档配置，然后 setup 跑起来就好了。

还需要手动加一些装饰器来标注：

- ApiOperation：声明接口信息
- ApiResponse：声明响应信息，一个接口可以多种响应
- ApiQuery：声明 query 参数信息
- ApiParam：声明 param 参数信息
- ApiBody：声明 body 参数信息，可以省略
- ApiProperty：声明 dto、vo 的属性信息
- ApiPropertyOptional：声明 dto、vo 的属性信息，相当于 required: false 的 ApiProperty
- ApiTags：对接口进行分组
- ApiBearerAuth：通过 jwt 的方式认证，也就是 Authorization: Bearer xxx
- ApiCookieAuth：通过 cookie 的方式认证
- ApiBasicAuth：通过用户名、密码认证，在 header 添加 Authorization: Basic xxx

swagger 是 openapi 标准的实现，可以在 url 后加个 -json 拿到对应的 json，然后导入别的接口文档平台来用。

绝大多数公司的接口文档都是用 swagger 来自动生成的，不然手动维护太麻烦了。

而且 swagger 还可以方便的测试接口，自动添加身份认证等。

你们公司用的是 swagger 生成的接口文档么？
