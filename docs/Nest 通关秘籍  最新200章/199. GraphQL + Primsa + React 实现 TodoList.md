# 199. GraphQL + Primsa + React 实现 TodoList

我们经常用 restful 的接口来开发业务。

比如 GET 请求 /students 查询所有学生，/students/1 查询 id 为 1 的学生

发送 POST、PUT、DETETE 请求分别代表增删改。

其实也可以用 GraphQL 的方式来写接口：

查询：
![](./images/9c147c040895b712149fe57f5a8823ca.webp )

新增：
![](./images/d044548544ba7813ee0f61ae07b6372f.webp )

![](./images/5c0da6afdd3676ae8cb920d564a5a3a2.webp )

增删改查都在一个接口里搞定，并且想要什么数据由前端自己取。

今天我们就用 Nest + GrahQL 做一个 TodoList 的增删改查。

数据存在 mysql 里，用 Prisma 作为 ORM 框架。

```bash
npm install -g @nestjs/cli

nest new graphql-todolist
```
![](./images/2ddfeee0855d21b37ad64f24d05c3f3e.webp )

创建个项目，然后我们首先来实现 restful 接口的增删改查。

用 docker 把 mysql 跑起来：

从 docker 官网下载 docker desktop，这个是 docker 的桌面端：

![](./images/525136bc8fb00f0d2e634b1d349094c8.webp )

跑起来后，搜索 mysql 镜像（这步需要科学上网），点击 run：

![](./images/b9d1cc0a9a1f796bc584276e01e8d63e.webp )

输入容器名、端口映射、以及挂载的数据卷，还要指定一个环境变量：

![](./images/9281a95f17590da8f9f7711677bdb12c.webp )

端口映射就是把宿主机的 3306 端口映射到容器里的 3306 端口，这样就可以在宿主机访问了。

数据卷挂载就是把宿主机的某个目录映射到容器里的 /var/lib/mysql 目录，这样数据是保存在本地的，不会丢失。

而 MYSQL\_ROOT\_PASSWORD 的密码则是 mysql 连接时候的密码。

![](./images/83e1341810c7235012cc2063f95da9d9.webp )

跑起来后，我们用 GUI 客户端连上，这里我们用的是 mysql workbench，这是 mysql 官方提供的免费客户端：

![](./images/a084ce06fd2a02cd1913a06e56069c3c.webp )

连接上之后，点击创建 database：

![](./images/2e6e86093be78c4f049d047b28dd386a.webp )

指定名字、字符集为 utf8mb4，然后点击右下角的 apply。

创建成功之后在左侧就可以看到这个 database 了：

![](./images/7628927c0d51f7a3acd498e586022ded.webp )

现在还没有表。

我们在 Nest 里用 Prisma 连接 mysql。

进入项目，安装 prisma

```bash
npm install prisma --save-dev
```
执行 prisma init 创建 schema 文件：

```bash
npx prisma init
```
![](./images/2838042fbcdaa8ed79443d2fe33853b4.webp )

生成了 schema 文件（用来定义 model 的），和 .env 文件：

![](./images/9853b168fa9d95b206fbeb1cfa4063bc.webp )

改下 .env 的配置：

```env
DATABASE_URL="mysql://root:你的密码@localhost:3306/todolist"
```

并且修改下 schema 里的 datasource 部分：

```javascript
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

然后创建 model：

![](./images/0f5c89d41b97d7ce2985f3facd244e9d.webp )

```javascript
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model TodoItem {
  id        Int    @id @default(autoincrement())
  content    String  @db.VarChar(50)
  createTime DateTime @default(now())
  updateTime DateTime @updatedAt
}
```
id 自增，content 是长度为 50 的字符串，还有创建时间 createTime、更新时间 updateTime。

执行 prisma migrate dev，它会根据定义的 model 去创建表：

```
npx prisma migrate dev --name init
```
![](./images/455e8205b8345d7d6143c893a716ed15.webp )

它会生成 sql 文件，里面是这次执行的 sql。

然后还会生成 client 代码，用来连接数据库操作这个表。

可以看到，这次执行的 sql 就是 create table 建表语句：

![](./images/f3178bf6ca23e2d6e715aa475cd62007.webp )

这时候数据库就就有这个表了：

![](./images/dd9354d7307ecb550d00677f948fc94c.webp )

接下来我们就可以在代码里做 CRUD 了。

生成一个 service：

```
nest g service prisma --flat --no-spec
```
![](./images/d5cfdeee6717504891f8ae6c6d69ced9.webp )

改下生成的 PrismaService，继承 PrismaClient，这样它就有 crud 的 api 了：

```javascript
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {

    constructor() {
        super({
            log: [
                {
                    emit: 'stdout',
                    level: 'query'
                }
            ]
        })
    }

    async onModuleInit() {
        await this.$connect();
    }
}
```
在 constructor 里设置 PrismaClient 的 log 参数，也就是打印 sql 到控制台。

在 onModuleInit 的生命周期方法里调用 $connect 来连接数据库。

然后在 AppService 里注入 PrismaService，实现 CRUD：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { CreateTodoList } from './todolist-create.dto';
import { UpdateTodoList } from './todolist-update.dto';

@Injectable()
export class AppService {

  getHello(): string {
    return 'Hello World!';
  }

  @Inject(PrismaService)
  private prismaService: PrismaService;

  async query() {
    return this.prismaService.todoItem.findMany({
      select: {
        id: true,
        content: true,
        createTime: true
      }
    });
  }

  async create(todoItem: CreateTodoList) {
    return this.prismaService.todoItem.create({
      data: todoItem,
      select: {
        id: true,
        content: true,
        createTime: true
      }
    });
  }

  async update(todoItem: UpdateTodoList) {
    return this.prismaService.todoItem.update({
      where: {
        id: todoItem.id
      },
      data: todoItem,
      select: {
        id: true,
        content: true,
        createTime: true
      }
    });
  }

  async remove(id: number) {
    return this.prismaService.todoItem.delete({
      where: {
        id
      }
    })
  }
}
```
@Inject 注入 PrismaService，用它来做 CRUD，where 是条件、data 是数据，select 是回显的字段：

![](./images/9eafdba727c75f0e989ad2fc9530daf4.webp )

然后创建用到的两个 dto 的 class

todolist-create.dto.ts

```javascript
export class CreateTodoList {
    content: string;
}
```

todolist-update.dto.ts

```
export class UpdateTodoList {
    id: number;
    content: string;
}
```
在 AppController 里引入下，添加几个路由：

```javascript
import { Body, Controller, Delete, Get, Post, Query } from '@nestjs/common';
import { AppService } from './app.service';
import { CreateTodoList } from './todolist-create.dto';
import { UpdateTodoList } from './todolist-update.dto';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Post('create')
  async create(@Body() todoItem: CreateTodoList) {
    return this.appService.create(todoItem);
  }

  @Post('update')
  async update(@Body() todoItem: UpdateTodoList) {
    return this.appService.update(todoItem);
  }

  @Get('delete')
  async delete(@Query('id') id: number) {
    return this.appService.remove(+id);
  }

  @Get('list')
  async list() {
    return this.appService.query();
  }

}
```
添加增删改查 4 个路由，post 请求用 @Body() 注入请求体，@Query 拿路径中的参数：

![](./images/21745214874aa772c192dd8ba8926c71.webp )

把服务跑起来试一下：

```
npm run start:dev
```

![](./images/e3e39d0a63a40f7986b2ba5bc594be99.webp )

首先是 list，现在没有数据：

![](./images/39424a76cbbd332e041541ae07f7baa5.webp )

然后添加一个：

![](./images/51fe735103c2bd39bcb910954fabc46a.webp )

服务端打印了 insert into 的 sql：

![](./images/91060cda9a378e107d63611bbea3fa2b.webp )

数据库也有了这条记录：

![](./images/aba41fc9ce72b68ccc350183f9df3ead.webp )

再加一个：

![](./images/7535529c46db5a318487cddee865af31.webp )

然后查一下：

![](./images/24d58200945c0baf28d58a2e8da96217.webp )

接下来试下修改、删除：

![](./images/a9c54648bdcae97e421a1836152b8156.webp )

![](./images/7bb42ba30c8046811472728164c9fea3.webp )

再查一下：

![](./images/b4ce289aaef1566afd589186721e745f.webp )

没啥问题。

这样，todolist 的 restful 版接口就完成了。

接下来实现 graphql 版本：

安装用到的包：

```bash
npm i @nestjs/graphql @nestjs/apollo @apollo/server graphql
```

然后在 AppModule 里引入下：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaService } from './prisma.service';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver } from '@nestjs/apollo';

@Module({
  imports: [
    GraphQLModule.forRoot({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
    })
  ],
  controllers: [AppController],
  providers: [AppService, PrismaService],
})
export class AppModule {}
```
typePaths 就是 schema 文件的路径：

![](./images/929e5fdfc65ab6efb643e56d78a2b0d4.webp )

添加一个 todolist.graphql

```graphql
type TodoItem {
    id: Int
    content: String
}

input CreateTodoItemInput {
  content: String
}

input UpdateTodoItemInput {
  id: Int!
  content: String
}

type Query {
  todolist: [TodoItem]!
  queryById(id: Int!): TodoItem
}


type Mutation {
  createTodoItem(todoItem: CreateTodoItemInput!): TodoItem!
  updateTodoItem(todoItem: UpdateTodoItemInput!): TodoItem!
  removeTodoItem(id: Int!): Int
}
```
语法比较容易看懂，就是定义数据的结构。

在 Query 下定义查询的接口，在 Mutation 下定义增删改的接口。

然后实现 resolver，也就是这些接口的实现：

```bash
nest g resolver todolist --no-spec --flat
```
![](./images/2970e62fb180bbfdbf34f9c4e6f391b6.webp )

```javascript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import { PrismaService } from './prisma.service';
import { Inject } from '@nestjs/common';
import { CreateTodoList } from './todolist-create.dto';
import { UpdateTodoList } from './todolist-update.dto';

@Resolver()
export class TodolistResolver {

    @Inject(PrismaService)
    private prismaService: PrismaService;

    @Query("todolist")
    async todolist() {
        return this.prismaService.todoItem.findMany();
    }

    @Query("queryById")
    async queryById(@Args('id') id) {
        return this.prismaService.todoItem.findUnique({
            where: {
                id
            }
        })
    }

    @Mutation("createTodoItem")
    async createTodoItem(@Args("todoItem") todoItem: CreateTodoList) {
        return this.prismaService.todoItem.create({
            data: todoItem,
            select: {
              id: true,
              content: true,
              createTime: true
            }
          });
    }


    @Mutation("updateTodoItem")
    async updateTodoItem(@Args('todoItem') todoItem: UpdateTodoList) {
        return this.prismaService.todoItem.update({
            where: {
              id: todoItem.id
            },
            data: todoItem,
            select: {
              id: true,
              content: true,
              createTime: true
            }
          });
    }

    @Mutation("removeTodoItem")
    async removeTodoItem(@Args('id') id: number) {
        await this.prismaService.todoItem.delete({
            where: {
              id
            }
        })
        return id;
    }
}
```

用 @Resolver 声明 resolver，用 @Query 声明查询接口，@Mutation 声明增删改接口，@Args 取传入的参数。

具体增删改查的实现和之前一样。

浏览器访问 http://localhost:3000/graphql 就是 playground，可以在这里查询：

![](./images/0121bb9d3b69fd7a111e2eed8ad14731.webp )

左边输入查询语法，右边是执行后返回的结果。

当然，对新手来说这个 playground 不够友好，没有提示。

我们换一个：

![](./images/021d715ec6545ae922a2bebc3d7d1a86.webp )

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaService } from './prisma.service';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver } from '@nestjs/apollo';
import { TodolistResolver } from './todolist.resolver';
import { ApolloServerPluginLandingPageLocalDefault } from '@apollo/server/plugin/landingPage/default';

@Module({
  imports: [
    GraphQLModule.forRoot({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
      playground: false,
      plugins: [ApolloServerPluginLandingPageLocalDefault()],
    })
  ],
  controllers: [AppController],
  providers: [AppService, PrismaService, TodolistResolver],
})
export class AppModule {}
```

![](./images/720bf577964ac812958f2b86b889e75c.gif )

试一下新增：

![](./images/5757199eb2fa7113aa20ed12bf139de4.webp )

查询：

![](./images/155014a75ef6326eab15b7d921f95a90.webp )

修改：

![](./images/1ddaabc97a658700a6a6c95a77771a37.webp )

单个查询：

![](./images/5ed877e4fd63cfd101754287283fd115.webp )

删除：

![](./images/bbc9486f0c5c5e94daeb7b02f5bfafb6.webp )

查询：

![](./images/acb94bc9a76b514a56326725e4a1c93c.webp )

基于 GraphQL 的增删改查都成功了！

然后在 react 项目里调用下。

```bash
npx create-vite
```

![](./images/c5808622721d8865aca1cda1d39fa899.webp )

进入项目，安装 @apollo/client

```bash
npm install

npm install @apollo/client
```
改下 main.tsx

```javascript
import * as ReactDOM from 'react-dom/client';
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';
import App from './App';

const client = new ApolloClient({
  uri: 'http://localhost:3000/graphql',
  cache: new InMemoryCache(),
});

const root = ReactDOM.createRoot(document.getElementById('root')!);

root.render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
);

```
创建 ApolloClient 并设置到 ApolloProvider。

然后在 App.tsx 里用 useQuery 发请求：

```javascript
import { gql, useQuery } from '@apollo/client';

const getTodoList = gql`
  query Query {
    todolist {
      content
      id
    }
  }
`;

type TodoItem = {
  id: number;
  content: string;
}

type TodoList = {
  todolist: Array<TodoItem>;
}

export default function App() {
  const { loading, error, data } = useQuery<TodoList>(getTodoList);

  if (loading) return 'Loading...';
  if (error) return `Error! ${error.message}`;

  return (
    <ul>
      {
        data?.todolist?.map(item => {
          return <li key={item.id}>{item.content}</li>
        })
      }
    </ul>
  );
}
```
把服务跑起来：

```
npm run dev
```

![](./images/242249f5e362461f70254cb97521e105.webp )

这里涉及到的跨域，现在后端服务里开启下跨域支持：

![](./images/f9ffa5d49be5ac72f2cebd2b347a866d.webp )

可以看到，返回了查询结果：

![](./images/78b9cb2a1a8e61222d20e8c0e19dc28e.webp )

然后加一下新增：

![](./images/29bb6a4f21bfd32a2720ef1f2a46808a.webp )

用 useMutation 的 hook，指定 refetchQueries 也就是修改完之后重新获取数据。

调用的时候传入 content 数据。

```javascript
import { gql, useMutation, useQuery } from '@apollo/client';

const getTodoList = gql`
  query Query {
    todolist {
      content
      id
    }
  }
`;

const createTodoItem = gql`
  mutation Mutation($todoItem: CreateTodoItemInput!) {
    createTodoItem(todoItem: $todoItem) {
      id
      content
    }
  }
`;

type TodoItem = {
  id: number;
  content: string;
}

type TodoList = {
  todolist: Array<TodoItem>;
}

export default function App() {
  const { loading, error, data } = useQuery<TodoList>(getTodoList);

  const [createTodo] = useMutation(createTodoItem, {
    refetchQueries: [getTodoList]
  });

  async function onClick() {
    await createTodo({
      variables: {
        todoItem: {
          content: Math.random().toString().slice(2, 10)
        }
      }
    })
  }

  if (loading) return 'Loading...';
  if (error) return `Error! ${error.message}`;

  return (
    <div>
      <button onClick={onClick}>新增</button>
      <ul>
        {
          data?.todolist?.map(item => {
            return <li key={item.id}>{item.content}</li>
          })
        }
      </ul>
    </div>
  );
}
```
测试下：

![](./images/354aa3c8a83a4f0bb994bca1264b75d9.gif )

数据库里也可能看到新增的数据：

![](./images/bcef7bd6dcade53a280d59e2692fe44a.webp )

这样，我们就能在 react 项目里用 graphql 做 CRUD 了。

案例代码上传了 github。

后端代码： https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/graphql-todolist

前端代码：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/graphql-todolist-client

## 总结

我们实现了 Restful 和 GraphQL 版的 CRUD。

前端用 React + @apollo/client。

后端用 Nest + GraphQL + Prisma + MySQL。

GraphQL 主要是定义 schema 和 resolver 两部分，schema 是 Query、Mutation 的结构，resolver 是它的实现。

可以在 playground 里调用接口，也可以在 react 里用 @appolo/client 调用。

相比 restful 的版本，graphql 只需要一个接口，然后用查询语言来查，需要什么数据取什么数据，更加灵活。

业务开发中，你会选择用 GraphQL 开发接口么？
