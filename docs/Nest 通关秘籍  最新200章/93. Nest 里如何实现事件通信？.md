# 93. Nest 里如何实现事件通信？

后端应用中会有很多业务模块，这些业务模块之间会有互相调用的关系。

但是把一个业务模块作为依赖注入的别的业务模块也不大好。

比如下单送优惠券的活动，订单模块在订单完成后调用优惠券模块下发优惠券。

这种如果直接把优惠券模块注入到订单模块里就不大好，因为是两个独立的业务模块。

有没有别的通信方式呢？

有，比如通过 event emitter 通信。

我们试一下：

```
nest new event-emitter-test
```

![](./images/0a8860723c380a7e6f68cfff142f60ad.webp )

安装用到的包：

```
npm i --save @nestjs/event-emitter
```
在 AppModule 引入下 EventEmitterModule：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { EventEmitterModule } from '@nestjs/event-emitter';

@Module({
  imports: [
    EventEmitterModule.forRoot(),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后创建两个 module：

![](./images/df33b1a8711ca0d6aecc78649336ed43.webp )

![](./images/d8cf62a2052990cb0c449d3c69578f59.webp )

把服务跑起来：

```
npm run start:dev
```

![](./images/1236db0c1c453e3d13b9b0bceb43fe74.webp )

访问下 aaa 和 bbb 的接口：

![](./images/4be280d05fce0c3a6bd27aa7132daa05.webp )

![](./images/61e47360d8b93f0941b2fe627caa53f7.webp )

没啥问题。

然后我们想在 aaa 模块的查询触发的时候，调用 bbb 模块记录一条日志呢？

这时候就可以用 Event Emitter 来做。

![](./images/0c14de124b199199b525dafd3818bfb5.webp )

```javascript
@Inject(EventEmitter2)
private eventEmitter: EventEmitter2;

findAll() {
    this.eventEmitter.emit('aaa.find',{
      data: 'xxxx'
    })
    return `This action returns all aaa`;
}
```
在 AaaService 里注入 EventEmitter2，然后调用它的 emit 方法发送一个事件。

然后在 BbbService 里监听下：

![](./images/78ce9b57c682fa537caaefa131c843d0.webp )

```javascript
@OnEvent('aaa.find')
handleAaaFind(data) {
    console.log('aaa find 调用', data)
    this.create(new CreateBbbDto());
}
```
试一下：

![](./images/7263bd6f35d6244bbe9d33378dfb8f1a.webp )

![](./images/6e07cfdb3375cf95d40b92f6adc794e9.webp )

可以看到 AaaService 的 findAll 调用的时候，自动触发了 BbbService 里的方法调用。

是不是很方便？

如果你没感觉出来，那想一下不通过事件怎么做呢？

是不是需要在 BbbModule 里把 BbbService 放到 exports 里声明，然后在 AaaModule 里引入之后 BbbModule 之后，注入它的 BbbService 来用呢？

或者通过全局模块，把 BbbModule 通过 @Global 声明为全局模块，然后在 AaaService 里注入 BbbService 来调用呢？

不管哪种都很麻烦。

而通过事件的方式就简单太多了。

此外，EventEmitterModule 还支持一些配置：

![](./images/ca7526cdf1abc530287e0f7020ac5148.webp )

wildcard 是允许通配符 *。

delimiter 是 namespace 和事件名的分隔符。

配置之后就可以这样用了：

![](./images/688f9fb00bfb237b0f648a1177d3251f.webp )

```javascript
findAll() {
    this.eventEmitter.emit('aaa.find',{
      data: 'xxxx'
    })

    this.eventEmitter.emit('aaa.find2',{
      data: 'xxxx2'
    })
    return `This action returns all aaa`;
}
```

BbbService 里可以用 aaa.* 通配符匹配：

![](./images/2c5a069c41abf4a04baa701daf23ca45.webp )

测试下：

![](./images/e74b085cf4051ca33109dbf727442524.webp )

![](./images/133d885cd738c83aaa379a9c1ed70ded.webp )

event emitter 用起来很简单，但却很有用，比直接引入模块注入依赖的方式方便太多了。

我们来做个具体案例，用户注册成功之后，通知模块里发送欢迎邮件：

```
nest g resource user --no-spec
nest g resource notification --no-spec
```
![](./images/47e279b12fa003ea225273676ac17631.webp )

![](./images/a4dd9f36a0ba34d2889f6e547965bfcd.webp )

```
nest g module email
nest g service email --no-spec
```
![](./images/38d47810af05009b86494df9035417ed.webp )

创建 user 用户模块、notification 通知模块，email 邮件模块。

先来写下邮件模块：

安装 nodemailer 包：

```
npm install --save nodemailer
```
写下 EmailService：

```javascript
import { Injectable } from '@nestjs/common';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor() {
      this.transporter = createTransport({
          host: "smtp.qq.com",
          port: 587,
          secure: false,
          auth: {
              user: "你的用户名",
              pass: "你的授权码"
          },
      });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '系统邮件',
          address: "你的邮箱地址"
        },
        to,
        subject,
        html
      });
    }

}
```
如何获取授权码看 [node 发邮件](https://juejin.cn/book/7226988578700525605/section/7247327089496424505)那节。

然后把 EmailModule 声明为全局模块：

```javascript
import { Global, Module } from '@nestjs/common';
import { EmailService } from './email.service';

@Global()
@Module({
  providers: [EmailService],
  exports: [EmailService]
})
export class EmailModule {}

```

这样 NotificationService 里就可以直接注入 EmailService 了：

![](./images/7e00cbb6077f4098c1e089704f3b0748.webp )

```javascript
@Inject(EmailService)
private emailService: EmailService

@OnEvent("user.register")
async hanldeUserRegister(data) {
    console.log('user.register');

    await this.emailService.sendMail({
      to: data.email,
      subject: '欢迎' + data.username,
      html: '欢迎新人'
    })
}
```

然后在 CreateUserDto 添加两个属性：

```javascript
export class CreateUserDto {
    username: string;
    email: string;
}
```
在 create 的时候调用下：

![](./images/0f05a25df2a15fc8749530dc3d7e52b4.webp )

```javascript
@Inject(EventEmitter2)
private eventEmitter: EventEmitter2;

create(createUserDto: CreateUserDto) {
    this.eventEmitter.emit('user.register', {
      username: createUserDto.username,
      email: createUserDto.email
    })

    return 'This action adds a new user';
}
```
在 postman 里调用下 create 接口：

![](./images/fbb84f505459a11ee8482fc73cede13b.webp )

![](./images/f697d8a625d5d16065949dc8cd23d023.webp )

![](./images/6db1f9940375e04b3821c4ef4068641d.webp )

通知成功了！

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/event-emitter-test)。
## 总结

多个业务模块之间可能会有互相调用的关系，但是也不方便直接注入别的业务模块的 Service 进来。

这种就可以通过 EventEmitter 来实现。

在一个 service 里 emit 事件和 data，另一个 service 里 @OnEvent 监听这个事件就可以了。

用起来很简单，但比起注入别的模块的 service 方便太多了。
