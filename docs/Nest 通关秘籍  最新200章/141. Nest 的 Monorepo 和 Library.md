# 141. Nest 的 Monorepo 和 Library

上节我们学习微服务时创建了 2 个 Nest 项目，如果微服务多了，可能会创建更多项目。

那问题来了，如果有 10 个微服务，我们就创建 10 个 Nest 项目的 git 仓库么？

![](./images/173df781ccfebcd46f69702ad0ff8347.png )

那肯定不行，太难维护了。

这时候我们就需要 monorepo 了。

![](./images/610eb4a569a86a8462ed0b012a417cec.png )

这样，同一个 git 仓库中存放多个 Nest 项目，外层叫做 workspace。

这样就算是 10 个微服务项目，也能在一个 Git 仓库里管理起来。

Nest 是支持这种 monorepo 的方式的，我们来试试看：

```
nest new monorepo-test
```
创建个 nest 项目

![](./images/266c371b7556ca36a05285d002673f39.png )

我们添加一个 aaa 的路由：

![](./images/5fde40ec11540aca6665d248656cbc88.png )

```javascript
@Get('aaa')
aaa() {
    return 'aaa';
}
```
改下端口：

![](./images/fb7c6e3ec8051047208d481d9d298dd5.png )

然后把它跑起来：

```
npm run start:dev
```

![](./images/8eebde44c7143d966caac828968c96b9.png )

浏览器访问下：

![](./images/2eb50ca5e7f7186072721f714a6bb181.png )

没啥问题。

然后我们再添加一个 nest 项目：

```
nest g app app2
```

![](./images/e2cd67a45240644a0067ad9d28b4909e.png )

它删除了 src 和 test，并创建了 apps 目录：

![](./images/42270257546bbe05fb3098091c3c1e97.png )

这里的 apps/monorepo-test 就是之前的 src、test 代码：

![](./images/a199681d79027961e5cd497fb3eefed5.png )

而 apps/app2 就是新创建的 nest 项目，或者叫 nest app。
 
![](./images/f09aff8d09db800790c8fc59770909af.png )

把之前的服务停掉，重新跑:

```
npm run start:dev
```
![](./images/11328f458a68f9d5e18eafd86c1dc844.png )

可以看到，跑的还是之前的那个 nest 项目，只不过换成了 webpack 编译。

![](./images/e7c313e176d2de94d44ad7146eea41d1.png )

为什么同样都是 nest run start:dev，换成 monorepo 的形式之后，还是跑之前项目呢？

答案在 nest-cli.json 里：

之前 nest-cli.json 是这样的：

![](./images/755e4217c2bbdf6fe001adbf38b41980.png )

现在变成了这样：

![](./images/f1948abb95a3f09396263829a3ae9553.png )

projects 下保存着多个 nest 项目的信息，比如根目录、入口文件、src 目录、编译配置文件。

然后 sourceRoot 和 root 分别指向了默认项目的 src 目录和根目录。

所以跑 nest start 的时候，才会依然跑的是之前的项目。

很明显，如果想跑另一个项目，就要这样：

```
npm run start:dev app2
```

![](./images/b92b0ead5bce7ad6b569a430155daf69.png )

比如我在 app2 添加一个 bbb 的路由：

![](./images/943bb298098591efcf15ff154fa53cdf.png )

```javascript
@Get('bbb')
bbb() {
    return 'bbb';
}
```
浏览器访问下：

![](./images/1ed1e3c478514f10aee4b2482dc76682.png )

这样，app2 的服务就跑起来了。

原理也很简单，就是 nest cli 会根据 app 名字去读取对应的 tscofnig 文件：

![](./images/9c08565bf65c3c6f03aa7831e5931920.png )

这就是 nest 的 monorepo。

项目多了以后，难免有一些公共代码，这种公共代码怎么复用呢？

这就涉及到 nest 的另一个特性了：library。

创建一个 library：

```
nest g lib lib1
```

![](./images/8b60ced89a13c1b546e6bb35508ceabc.png )

它会让你指定一个前缀，这里用默认的 @app。

然后会生成 libs/lib1 目录：

![](./images/fdaeda91cfbca64f40f2bcb95763c82b.png )

在 src 下生成了 module、service 并把它们导出了。

还在 tsconfig.json 的 paths 下添加了对应的别名配置：

![](./images/33bc1994c9f4fe05f9fa92b60ec82044.png )

在 nest-cli.json 里也多了这样一个 projects 配置：

![](./images/63d9438ff44e836ec630711b5079ee1f.png )

我们在 LibService 添加一个 xxx 方法：

![](./images/304de20dcb55613bfed73bc723f2b354.png )

```javascript
xxx() {
    return 'xxx';
}
```
然后在 monorepo-test 的 app 里导入 Lib1Module：

![](./images/ea996f99f66bc12c281afcc95684dde1.png )

在 controller 里注入 Lib1Service 并调用它的方法：

![](./images/2c5e5f6794a369d2940dd75fd7773647.png )

```javascript
@Inject(Lib1Service)
private lib : Lib1Service;

@Get('aaa')
aaa() {
    return 'aaa' + this.lib.xxx();
}
```
同样的方式，在 app2 里也导入并使用它：

![](./images/cb8a4e46c7af67f21a103181767b93e6.png )

![](./images/76d30cd00645e3e52702bc72fc0275f3.png )

```javascript
@Inject(Lib1Service)
private lib : Lib1Service;

@Get('bbb')
bbb() {
    return 'bbb' + this.lib.xxx();
}
```
然后分别把两个服务跑起来：

```
npm run start:dev

npm run start:dev app2
```

![](./images/570975921752714c5a00c8b9b7ffa494.png )


![](./images/fb51a2fb823217e48070aec9e2844573.png )

浏览器访问下 http://localhost:3001/aaa 和 http://localhost:3000/bbb

![](./images/69ad2a9ce49fc1b227d246a1dd8da95e.png )

![](./images/09d4cca374bfa5b441da60509473b3cd.png )

可以看到，引入的 library 中的模块生效了。

如果你只是改 lib 下的代码，不想跑服务时，可以单独编译 lib 代码：

```
npm run start:dev lib1
```
![](./images/f45fe6bf406ff53ce609a706584cd896.png )

nest 的 monorepo 和 libray 用起来都挺简单的。

还有个问题，现在 build 之后的代码是什么样的呢？

删掉 dist，然后执行：

```
npm run build
```
产生了一个 apps/monorepo-test/main.js，因为现在换成 webpack 了：

![](./images/40b0deff347dc0cc8bb563d2e06ce2dc.png )

然后执行：

```
npm run build app2
```
现在就多了 apps/app2/main.js 
![](./images/4a2d23beb0a72398a1a80f4fbc5ec994.png )

lib1 也是同理：
```
npm run build lib1
```
![](./images/3276f0c3c4094438d1133ee7456f6062.png )

之所以 application 或者 library 都能知道输出目录在哪，是因为在 tsconfig.json 里配了：

![](./images/5cc9b03a0d5c7c1457ab14e0adedae60.png )

![](./images/87f0a70d0003865f1c627574ac091597.png )

![](./images/6230331a271137d8f69d675aabf4bc2e.png )

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/monorepo-test)

## 总结

微服务项目可能会有很多个项目，为了方便管理，我们会使用 monorepo 的方式。

monorepo 就是在一个 git 仓库里管理多个项目。

nest cli 支持 monorepo，只要执行 nest g app xxx 就会把项目变为 monorepo 的，在 apps 下保存多个 nest 应用。

nest-cli.json 里配置了多个 projects 的信息，以及默认的 project。

npm run start:dev 或者 npm run build 可以加上应用名来编译对应的 app。

此外，多个项目可能有公共代码，这时候可以用 nest g lib xxx 创建 library。

library 保存在 libs 目录下，和 apps 一样可以有多个。

nest 会为 libs 创建别名，可以在其他 app 或者 lib 里用别名引入。

这就是 nest 里创建 monorepo 以及通过 library 复用代码的方式，用起来还是比较简单的。
