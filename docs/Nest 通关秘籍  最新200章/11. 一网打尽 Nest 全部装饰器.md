# 11. 一网打尽 Nest 全部装饰器

Nest 的功能都是大多通过装饰器来使用的，这节我们就把所有的装饰器过一遍。

我们创建个新的 nest 项目：

    nest new all-decorator -p npm

![](./images/710285627e9b5312f53ef0e860194f09.webp )

Nest 提供了一套模块系统，通过 @Module声明模块：

![](./images/d4b8451a925909a7d4ba332992b2b0e8.webp )

通过 @Controller、@Injectable 分别声明其中的 controller 和 provider：

![](./images/8f36a35ced6c8cef1a246f3b25edc7d3.webp )

![](./images/9ba1650c89da11defaf3b30cebc76581.webp )

这个 provider 可以是任何的 class：

![](./images/fd87cda2fa210fa8090b9b85fca5a70a.webp )

注入的方式可以是构造器注入：

![](./images/e3d7d1887ff0d52a2a853b3d3a9bbaf4.webp )

或者属性注入：

![](./images/06334540717580a921f3996f405a41a5.webp )

属性注入要指定注入的 token，可能是 class 也可能是 string。

你可以通过 useFactory、useValue 等方式声明 provider：

![](./images/bda6c0fd5629835395a2bcd9bce72aee.webp )

这时候也需要通过 @Inject 指定注入的 token：

![](./images/0ecb415926273497a1dcd8691230c590.webp )

![](./images/1eb3fa49cdc504301600f311eb1af432.webp )

这些注入的依赖如果没有的话，创建对象时会报错。但如果它是可选的，你可以用 @Optional 声明一下，这样没有对应的 provider 也能正常创建这个对象。

![](./images/e04df804d88117267ee6859a5d8680fc.webp )

如果模块被很多地方都引用，为了方便，可以用 @Global 把它声明为全局的，这样它 exports 的 provider 就可以直接注入了：

![](./images/3fddecffabaa609d821c572385a29202.webp )

filter 是处理抛出的未捕获异常的，通过 @Catch 来指定处理的异常：

![](./images/ecd7dd75452a6dd9c220bea46870107a.webp )

然后通过 @UseFilters 应用到 handler 上：

![](./images/1491bbd56adaadf467095eda6861a687.webp )

![](./images/d5cc3cd54a74ff2b2d6b15ced8d62cf4.webp )

除了 filter 之外，interceptor、guard、pipe 也是这样用：

![](./images/d3c1e09b2f646d2ae75f999134dbf491.webp )

当然，pipe 更多还是单独在某个参数的位置应用：

![](./images/51b9962eb893124308db67b55d84607d.webp )

这里的 @Query 是取 url 后的 ?bbb=true，而 @Param 是取路径中的参数，比如 /xxx/111 种的 111

![](./images/52c3779f5d8c2898169539df961fadec.webp )

![](./images/e640ded44a806f43d1e4954d9bc45715.webp )

此外，如果是 @Post 请求，可以通过 @Body 取到 body 部分：

![](./images/b20486f5d13f609af1d9c57212ceba8a.webp )

我们一般用 dto 的 class 来接受请求体里的参数：

![](./images/8d8a1befae67350f510a423487470c87.webp )

nest 会实例化一个 dto 对象：

用 postman 发个 post 请求：

![](./images/0a361ce85a61667e41799d70126c1e67.webp )

可以看到 nest 接受到了 body 里的参数：

![](./images/c2ba8480ef40607161295a31e21b9ada.webp )

除了 @Get、@Post 外，还可以用 @Put、@Delete、@Patch、@Options、@Head 装饰器分别接受 put、delete、patch、options、head 请求：

![](./images/d1a31f8a91e4f2c979ffe2f600cd39f4.webp )

handler 和 class 可以通过 @SetMetadata 指定 metadata：

![](./images/6cfbed6f7b9223089a191979749103c9.webp )

然后在 guard 或者 interceptor 里取出来：

![](./images/c45dd3432361ec9f5206f62b4eef18b5.webp )

![](./images/5d1bb90fe87fd20e7201b0c029710593.webp )

你可以通过 @Headers 装饰器取某个请求头 或者全部请求头：

![](./images/a8e323bed50e6c47c47f03887a4c2d2e.webp )

![](./images/76ad5f799cfa2d1de2e0e22d256b54a8.webp )

通过 @Ip 拿到请求的 ip：

![](./images/2d40cc2c9245ff0b62b13a980a7defb6.webp )

通过 @Session 拿到 session 对象：

![](./images/e4aa73019e4244a3c24506e839e2d880.webp )

但要使用 session 需要安装一个 express 中间件：

    npm install express-session

在 main.ts 里引入并启用：

![](./images/6fb3424c386043c81d5df009371bf79d.webp )

指定加密的密钥和 cookie 的存活时间。

然后刷新页面：

![](./images/729a805e0f104c3028878e6ee254565c.webp )

会返回 set-cookie 的响应头，设置了 cookie，包含 sid 也就是 sesssionid。

之后每次请求都会自动带上这个 cookie：

![](./images/ec3d239e627dad1a265862c9487dd6c5.webp )

这样就可以在 session 对象里存储信息了。

![](./images/ccfb3691c9021401930fb4a3928421d2.webp )

![](./images/29becd24308fbe706865ef2ea148dbb9.webp )

@HostParam 用于取域名部分的参数：

我们再创建个 controller：

    nest g controller aaa --no-spec --flat

![](./images/100631a1e6afb2538131b5b83a9747c6.webp )

这样指定 controller 的生效路径：

```javascript
import { Controller, Get, HostParam } from '@nestjs/common';

@Controller({ host: ':host.0.0.1', path: 'aaa' })
export class AaaController {
    @Get('bbb')
    hello() {
        return 'hello';
    }
}
```

controller 除了可以指定某些 path 生效外，还可以指定 host：

![](./images/074a175e7fe8e7337f5ba3c6311f2303.webp )

然后再访问下：

![](./images/2b703200e7e25ec45727feb4b1683b73.webp )

这时候你会发现只有 host 满足 xx.0.0.1 的时候才会路由到这个 controller。

host 里的参数就可以通过 @HostParam 取出来：

```javascript
import { Controller, Get, HostParam } from '@nestjs/common';

@Controller({ host: ':host.0.0.1', path: 'aaa' })
export class AaaController {
    @Get('bbb')
    hello(@HostParam('host') host) {
        return host;
    }
}
```

![](./images/d48824b9c420020cafee7d202de6b82b.webp )

前面取的这些都是 request 里的属性，当然也可以直接注入 request 对象：

![](./images/be72c11e4af95595c3310d757ed1c4ea.webp )

通过 @Req 或者 @Request 装饰器，这俩是同一个东西：

![](./images/85d7c46017db36ebd5640c5871e1b90a.webp )

注入 request 对象后，可以手动取任何参数：

![](./images/bddc1055ff0327f7ea7d6ab03d33fb08.webp )

当然，也可以 @Res 或者 @Response 注入 response 对象，只不过 response 对象有点特殊：

![](./images/78d32fb8e737d8fe1f37664c0851180d.webp )

当你注入 response 对象之后，服务器会一直没有响应：

![](./images/de6c32f4d8a556d819ddba8c72a1541a.webp )

因为这时候 Nest 就不会再把 handler 返回值作为响应内容了。

你可以自己返回响应：

![](./images/8450a89095d8d143869421afe08f6ef1.webp )

![](./images/2a76ef30d067ef0168476adce50fca28.webp )

Nest 这么设计是为了避免你自己返回的响应和 Nest 返回的响应的冲突。

如果你不会自己返回响应，可以通过 passthrough 参数告诉 Nest：

![](./images/dbc3f65b4881c6b6b3eef53d73a5ab53.webp )

![](./images/2a76ef30d067ef0168476adce50fca28.webp )

除了注入 @Res 不会返回响应外，注入 @Next 也不会：

![](./images/320f68d173d2c578f6009077bc59843e.webp )

当你有两个 handler 来处理同一个路由的时候，可以在第一个 handler 里注入 next，调用它来把请求转发到第二个 handler：

![](./images/9396c7b03b512911134c9aab23d9803b.webp )

Nest 不会处理注入 @Next 的 handler 的返回值。

handler 默认返回的是 200 的状态码，你可以通过 @HttpCode 修改它：

![](./images/f5217f44c87ccb8f6fd8ab5e9a83a342.webp )

![](./images/63a5e8d429406c454d6193458e886867.webp )

当然，你也可以修改 response header，通过 @Header 装饰器：

![](./images/1d42847c5de6445cd03f3c59cb6cac81.webp )

![](./images/de1600eb74c7e64ea12d7fca6afdc03c.webp )

此外，你还可以通过 @Redirect 装饰器来指定路由重定向的 url：

![](./images/20c10159ca26d7ce5d08d5bee93c16aa.webp )

![](./images/ed46081a4c57f4c02c2ddfac8a92a460.webp )

或者在返回值的地方设置 url：

```javascript
@Get('xxx')
@Redirect()
async jump() {
    return {
      url: 'https://www.baidu.com',
      statusCode: 302
    }  
}
```

你还可以给返回的响应内容指定渲染引擎，不过这需要先这样设置：

![](./images/4b542eb860a353c502c9e021a53b61af.webp )

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.useStaticAssets(join(__dirname, '..', 'public'));
  app.setBaseViewsDir(join(__dirname, '..', 'views'));
  app.setViewEngine('hbs');

  await app.listen(3000);
}
bootstrap();

```

分别指定静态资源的路径和模版的路径，并指定模版引擎为 handlerbars。

当然，还需要安装模版引擎的包 hbs：

    npm install --save hbs

然后准备图片和模版文件：

![](./images/ddbad9afb56f16d80253461a9d13be6b.webp )

![](./images/8ecba5b4e660a7de4668279d6139b505.webp )

在 handler 里指定模版和数据：

![](./images/091ad562950ad7a0c1c7500dde63ded9.webp )

就可以看到渲染出的 html 了：

![](./images/d4abe5ca90cb87968c5775f26f8c9cb7.webp )

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/all-decorator)。

## 总结

这节我们梳理了下 Nest 全部的装饰器

*   @Module： 声明 Nest 模块
*   @Controller：声明模块里的 controller
*   @Injectable：声明模块里可以注入的 provider
*   @Inject：通过 token 手动指定注入的 provider，token 可以是 class 或者 string
*   @Optional：声明注入的 provider 是可选的，可以为空
*   @Global：声明全局模块
*   @Catch：声明 exception filter 处理的 exception 类型
*   @UseFilters：路由级别使用 exception filter
*   @UsePipes：路由级别使用 pipe
*   @UseInterceptors：路由级别使用 interceptor
*   @SetMetadata：在 class 或者 handler 上添加 metadata
*   @Get、@Post、@Put、@Delete、@Patch、@Options、@Head：声明 get、post、put、delete、patch、options、head 的请求方式
*   @Param：取出 url 中的参数，比如 /aaa/:id 中的 id
*   @Query: 取出 query 部分的参数，比如 /aaa?name=xx 中的 name
*   @Body：取出请求 body，通过 dto class 来接收
*   @Headers：取出某个或全部请求头
*   @Session：取出 session 对象，需要启用 express-session 中间件
*   @HostParm： 取出 host 里的参数
*   @Req、@Request：注入 request 对象
*   @Res、@Response：注入 response 对象，一旦注入了这个 Nest 就不会把返回值作为响应了，除非指定 passthrough 为true
*   @Next：注入调用下一个 handler 的 next 方法
*   @HttpCode： 修改响应的状态码
*   @Header：修改响应头
*   @Redirect：指定重定向的 url
*   @Render：指定渲染用的模版引擎

把这些装饰器用熟，就掌握了 nest 大部分功能了。
