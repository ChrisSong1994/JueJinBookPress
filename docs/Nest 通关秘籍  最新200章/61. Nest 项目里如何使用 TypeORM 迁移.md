上节我们学了 TypeORM 的 migration。

在开发环境下，我们会开启 syncronize，自动同步 entities 到数据库表。

包括 create table 和后续的 alter table。

但是在生产环境下，我们会把它关闭，用 migration 把表结构的变动、数据初始化管理起来。

通过 migration:run、migration:revert 命令来执行和撤销。

在 Nest 项目里使用 migration 和上节的内容还有点不太一样。

这节我们来试一下：

```
nest new nest-typeorm-migration
```

![](./images/c9cbbd945c754e54d612061cc81e1789.png )

创建个 nest 项目。

安装 typeorm 相关的包：

```bash
npm install --save @nestjs/typeorm typeorm mysql2
```
在 AppModule 引入下下：

![](./images/0badabfd73fa1a6abd670c1964b0bc07.png )

```javascript
TypeOrmModule.forRoot({
  type: "mysql",
  host: "localhost",
  port: 3306,
  username: "root",
  password: "guang",
  database: "nest-migration-test",
  synchronize: true,
  logging: true,
  entities: [],
  poolSize: 10,
  connectorPackage: 'mysql2',
  extra: {
      authPlugin: 'sha256_password',
  }
}),
```
然后创建个 article 模块：

```
nest g resource article
```

![](./images/0590e3f962a644a169af722ae384a3e5.png )

改下 article.entity.ts

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class Article {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 30
    })
    title: string;

    @Column({
        type: 'text'
    })
    content: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
}
```
引入下：

![](./images/33dd0f0a7158887bc71894eaa812d8b2.png )

然后在 mysql workbench 创建这个 database：

![](./images/d8db54110a04f4821ac966365ecefa5a.png )

![](./images/eb3dcbcd5211887a39aec75c187c28d9.png )

把服务跑起来：

```
npm run dev
```

![](./images/16f2537b424bba96a991427dde460d7e.png )

可以看到，自动创建了 ariticle 的表。

这就是 syncronize 设为 true 的效果。

![](./images/380f39f9b9406c7f943555def7c4b9fa.png )

然后我们添加一些数据：

![](./images/422c4d4efd9236404079427bc384c899.png )

```javascript
@InjectEntityManager()
entityManager: EntityManager;

async initData() {
    const a1 = new Article();
    a1.title = "夏日经济“热力”十足 “点燃”文旅消费新活力";
    a1.content = "人民网北京6月17日电 （高清扬）高考结束、暑期将至，各地文旅市场持续火热，暑期出游迎来热潮。热气腾腾的“夏日经济”成为消费活力升级的缩影，展示出我国文旅产业的持续发展势头。";

    const a2 = new Article();
    a2.title = "科学把握全面深化改革的方法要求";
    a2.content = "科学的方法是做好一切工作的重要保证。全面深化改革是一场复杂而深刻的社会变革，必须运用科学方法才能取得成功。";

    await this.entityManager.save(Article, a1);
    await this.entityManager.save(Article, a2);
}
```
在 ArticleService 添加 initData 方法，然后在 ArticleController 里调用下：

![](./images/cef57907e3b7782ddb5ec41b96db3ead.png )

```javascript
@Get('init-data')
async initData() {
    await this.articleService.initData();
    return 'done';
}
```
然后浏览器访问下：

![](./images/a67a43b506f1d0a0e92670441a21d3eb.png )

可以看到，数据插入成功了：

![](./images/597a871b0d0304a9d0e3e6b09a923a66.png )

![](./images/8bd1822b382dba42ec6f9787eeaca22b.png )

然后在查询接口里查一下：

![](./images/111519050517db2680dd877a9fbb4831.png )

```javascript
async findAll() {
    return  this.entityManager.find(Article);
}
```
访问下：

![](./images/edab3d0be3691e1459a06896011f44ac.png )

没啥问题。

如果这个 article 的数据是要在生产环境里用的。

而生产环境会关掉 syncronize，那怎么创建表和插入初始化数据呢？

前面讲过，用 migration。

首先需要创建 src/data-source.ts

```javascript
import { DataSource } from "typeorm";
import { Article } from "./article/entities/article.entity";

export default new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "nest-migration-test",
    synchronize: false,
    logging: true,
    entities: [Article],
    poolSize: 10,
    migrations: ['src/migrations/**.ts'],
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
});
```
注意，这里 synchronize 是 false，顺便也把 AppModule 里的那个 synchronize 也改为 false。

然后添加几个 npm scripts：

![](./images/429b97aae7f7d5079caa89f7b2f5517f.png )

```javascript
"typeorm": "ts-node ./node_modules/typeorm/cli",
"migration:create": "npm run typeorm -- migration:create",
"migration:generate": "npm run typeorm -- migration:generate -d ./src/data-source.ts",
"migration:run": "npm run typeorm -- migration:run -d ./src/data-source.ts",
"migration:revert": "npm run typeorm -- migration:revert -d ./src/data-source.ts"
```
我们先在数据库里导出现有数据：

![](./images/1df5591d60ca16d6bc2ec7a2579372fd.png )

![](./images/beb485fe0e3b14138c1d4c9214adbebc.png )

第一个选项是每个表一个 sql 文件，你也可以选择第二个选项，全部导出一个 sql 文件里：

![](./images/7fb91b204332201b8a79aded1b156b84.png )

打开看下：

![](./images/dd7989f4b871bd6f0d9dfe8b32b63f1d.png )

包含了 create table 和 insert 语句。

生产环境关掉 synchronize 后，只要执行这个 sql 就行。

但我们要通过 migration 的方式来执行 sql。

在 mysql workbench 里删掉这两张表：

![](./images/34846abf1e334199fc359fb672c6b1f5.png )

然后执行 migration:generate 命令：

```
npm run migration:generate src/migrations/init
```

![](./images/10a8d110f154f2db5f999802c550341f.png )

它会对比 entity 和数据表的差异，生成迁移 sql：

![](./images/2e7dd6088c14e33f9cb916dda67b3069.png )

可以看到，生成的 migration 类里包含了 create table 的 sql。

跑下试试：

```
npm run migration:run
```
![](./images/403fe41ecebbd4be84bbcbe0aad567d4.png )

可以看到，执行了两条 create table 语句。

在数据库里看下：

![](./images/a644705d9719a21f94ce3a78a5cda080.png )

migrations 表里记录了执行过的 migration，已经执行过的不会再执行。

article 表就是我们需要在生产环境创建的表：

![](./images/d0840b43df1f62611062ff359c2509e4.png )

然后我们再创建个 migration 来初始化数据：

```
npm run migration:create src/migrations/data
```
![](./images/befe342e59527a9a60f3c9c505014b35.png )

**migration:generate 只会根据表结构变动生成迁移 sql，而数据的插入的 sql 需要我们自己添加。**

严格来说数据初始化不能叫 migration，而应该叫 seed，也就是种子数据。

不过我们都是通过 migration 来管理。

![](./images/a0128d0a04fbb289776a06c5b0fd93ad.png )

在生成的迁移 class 里填入 insert into 的 sql 即可。

把刚才导出的那个 sql 里的 insert into 语句复制过来。

![](./images/0150cd951100da26fca9c26e6cef7f96.png )

![](./images/22bdef9e3c40a28bf7bd9e3e91a8895c.png )

```javascript
public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query("INSERT INTO `article` VALUES (1,'夏日经济“热力”十足 “点燃”文旅消费新活力','人民网北京6月17日电 （高清扬）高考结束、暑期将至，各地文旅市场持续火热，暑期出游迎来热潮。热气腾腾的“夏日经济”成为消费活力升级的缩影，展示出我国文旅产业的持续发展势头。','2024-06-18 08:56:21.306445','2024-06-18 08:56:21.306445'),(2,'科学把握全面深化改革的方法要求','科学的方法是做好一切工作的重要保证。全面深化改革是一场复杂而深刻的社会变革，必须运用科学方法才能取得成功。','2024-06-18 08:56:21.325168','2024-06-18 08:56:21.325168');")
}
```
如果你要支持 revert，那 down 方法里应该补上 delete 语句，这里我们就不写了。

然后跑一下：

![](./images/0f2df5a9d3a83577eccbb85134b813df.png )

可以看到，在 article 表插入了两条记录。

然后在 migrations 表里插入了一条记录。

为啥上次的 migration 就没执行了呢？

因为 migrations 表里记录过了呀，记录过的就不会再执行。

![](./images/dd9693a5d864bd23a8fcf70d9b9a32b6.png )

![](./images/ed1a503fd4a0574baea774fbd8312a7a.png )

这样怎么在生产环境 create table、insert into 数据我们就都知道了。

然后再来试下后续表结构的修改。

因为生产环境关掉了 syncronize，那 entity 变了之后如何修改表结构呢？

自然也是 migration。

Article 实体加一个 tags字段：

![](./images/f07ebb54a750d5d2bcde1709cab13b6f.png )

```javascript
@Column({
    length: 30
})
tags: string;
```
执行 migration:generate 命令：
```
npm run migration:generate src/migrations/add-tag-column
```
![](./images/f4e54aa6ed3633c1b7923b52c833ffb1.png )

生成了 alter table 的 sql：

![](./images/a0e3748a1ab53ac55bc097ef73236b30.png )

然后执行下这个 migration：

```
npm run migraion:run
```

![](./images/fa253be28306f75cda199bc307e7a766.png )

一条 alter table 的 sql，一条 insert 的 sql。

可以看到，article 表多了 tags 列，migrations 表也插入了一条执行记录：

![](./images/428b2ff7eb410afbef78ac73f6318c67.png )

![](./images/3e74ee83b6eeadc1201424bd1f59080a.png )

这样，如何在生产环境通过 migration 创建表、修改表、初始化数据我们就都清楚了。

此外，有同学可能会说，我们的数据库连接配置都是放在 config 文件里的，现在两个地方都要用，那如何两个地方都读取配置文件呢？

我们在 src 下创建 .env

```javascript
# 61. Nest 项目里如何使用 TypeORM 迁移
mysql_server_host=localhost
mysql_server_port=3306
mysql_server_username=root
mysql_server_password=guang
mysql_server_database=nest-migration-test
```
首先，AppModule 里的这些数据库配置都可以从 .env 里读取：

![](./images/df9024f0b87dc8e0ecb0351d1688db6f.png )

用到 ConfigModule，这个是下节的内容，这里就不展开了：

![](./images/b96a890d55c2e0721b9e747a0e957c04.png )

我们来看下在 data-source.ts 里怎么读取 .env 文件：

我们需要安装 dotenv 这个包：

```
npm install --save-dev dotenv
```

用 dotenv 来读取 .env 配置文件：

```javascript
import { DataSource } from "typeorm";
import { Article } from "./article/entities/article.entity";
import { config } from 'dotenv';

config({ path: 'src/.env' });

console.log(process.env);

export default new DataSource({
    type: "mysql",
    host: `${process.env.mysql_server_host}`,
    port: +`${process.env.mysql_server_port}`,
    username: `${process.env.mysql_server_username}`,
    password: `${process.env.mysql_server_password}`,
    database: `${process.env.mysql_server_database}`,
    synchronize: false,
    logging: true,
    entities: [Article],
    poolSize: 10,
    migrations: ['src/migrations/**.ts'],
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
});
```
跑一下：

```
npm run migration:run
```
![](./images/3d5a9288b22077d123b7b8e5de16b961.png )

可以看到，.env 的配置读取成功了。

这样，AppModule 和迁移用的 data-source.ts 里就都可以读取同一份配置。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-typeorm-migration)。

## 总结

生产环境是通过 migration 来创建表、更新表结构、初始化数据的。

这节我们在 nest 项目里实现了下迁移。

大概有这几步：

- 创建 data-source.ts 供 migration 用
- 把 synchronize 关掉
- 用 migration:generate 生成创建表的 migration
- 用 migration:run 执行
- 用 migration:create 创建 migration，然后填入数据库导出的 sql 里的 insert into 语句
- 用 migration:run 执行
- 用 migration:generate 生成修改表的 migration
- 用 migration:run 执行

在生产环境下，我们就是这样创建表、更新表、初始化数据的。
