# 48. 一对多、多对多关系的表设计

上节我们学了一对一，这节继续来学习一对多和多对多。

一对多关系在生活中随处可见：

一个作者可以写多篇文章，而每篇文章只属于一个作者。

![](./images/c05fcff5739cc419355c02956618011a.webp )

一个订单有多个商品，而商品只属于一个订单。

![](./images/0bd29b03ecf5002faa43d4dc20a7d21f.webp )

一个部门有多个员工，员工只属于一个部门。

![](./images/c8133dd222aec39363e4fee88400a8dd.webp )

多对多的关系也是随处可见：

一篇文章可以有多个标签，一个标签可以多篇文章都有。

![](./images/4590e4f6f06514b2509833f9ff9cfe55.webp )

一个学生可以选修多门课程，一门课程可以被多个学生选修。

![](./images/60445eeb9ab432354d006aaf1b1d89bb.webp )

一个用户可以有多个角色，一个角色可能多个用户都有。

![](./images/19819071a034726d069acc8f074e86f4.webp )

那在数据库里如何建模这种关系呢？

我们分别来看一下：

一对多的关系，比如一个部门有多个员工。

我们会有一个部门表和一个员工表：

![](./images/d8bd338b3bab2a4dd2575077e89c02ad.webp )

在员工表添加外键 department\_id 来表明这种多对一关系：

![](./images/3b63d76f9f0e6bcf342a26715bee00da.webp )

其实和一对一关系的数据表设计是一样的。

我们添加这两个表。

![](./images/a1fa447d51758c9cddf671ee85fa7540.webp )

分别指定 id 是 INT，约束为 primary key、not null、 auto increment 。

name 是 VARCHAR(45)，约束为 not null。

点击 apply。

建表 sql 如下：

![](./images/22dc22e9f0297ad3cf113cda1b89c8ac.webp )

同样的方式创建 employee 表：

![](./images/28565c7ff75c80f08c80603ec8d73c82.webp )

添加 id、name、department\_id 这 3 列。

然后添加一个外键约束，department\_id 列引用 department 的 id 列。

设置级联删除和更新为 SET NULL。

因为部门没了员工不一定也没了，可能还会分配到别的部门。

![](./images/8b615b06b26e13b6dba35ab6ff6d48ec.webp )

点击 apply 就创建成功了。

![](./images/8c80a21a6c84d094710906a0f0bc8ab9.webp )

sql 的最后这段，就是创建了一个外键约束，department\_id 引用了 department 表的 id，设置级联删除和更新方式为 SET NULL。

我们往部门表插入几条数据：

```sql
INSERT INTO `department` (`id`, `name`) 
    VALUES 
        (1, '人事部'),
        (2, '财务部'),
        (3, '市场部'),
        (4, '技术部'),
        (5, '销售部'),
        (6, '客服部'),
        (7, '采购部'),
        (8, '行政部'),
        (9, '品控部'),
        (10, '研发部');
```

![](./images/85702350b767b63f074ee21f6d9fd94a.webp )

查询下：

![](./images/ab64d9ca03e8ef48077734e996471775.webp )

插入成功了。

再往员工表里插入几条数据：

```sql
INSERT INTO `employee` (`id`, `name`, `department_id`)
    VALUES 
        (1, '张三', 1),
        (2, '李四', 2), 
        (3, '王五', 3),
        (4, '赵六', 4),
        (5, '钱七', 5),
        (6, '孙八', 5),
        (7, '周九', 5),
        (8, '吴十', 8),
        (9, '郑十一', 9),
        (10, '王十二', 10);
```

![](./images/203ef5d5b03c02911215a78dfcf39f77.webp )

查询下：

![](./images/1bbf89df70c1585b31a02081dff765c4.webp )

同样插入成功了。

我们通过 JOIN ON 关联查询下 id 为 5 的部门的所有员工：

```sql
select * from department
    join employee on department.id = employee.department_id
    where department.id = 5
```

可以看到，正确查找出了销售部的 3 个员工：

![](./images/f68d03e20455f712756caaafeba77229.webp )

JOIN ON 默认是 INNER JOIN。

我们再来试试 LEFT JOIN 和 RIGHT JOIN：

```sql
select * from department
    left join employee on department.id = employee.department_id
```

from 后的是左表，可以看到两个还没有员工的部门也显示在了结果里：

![](./images/8085635c2321f206fb1abf6487579494.webp )

然后是 RIGHT JOIN：

```sql
select * from department
    right join employee on department.id = employee.department_id
```

因为所有的员工都是有部门的，所以和 inner join 结果一样：

![](./images/eff41c04aa8a07ae8762eccdb3d3b75e.webp )

然后把 id 为 5 的部门删掉：

![](./images/ec54845a083b4c2efc465e9a9e93a2cd.webp )

点击 apply。

再查看下员工表，可以看到销售部下的 3 个员工的部门被设置为 null 了：

![](./images/686128193e79195adde40eb2b26819ce.webp )

这就是 set null 的级联删除处理。

一对多是不是还挺简单的？

确实，它和一对一没啥本质的区别。

接下来我们来看多对多。

比如文章和标签：

![](./images/4590e4f6f06514b2509833f9ff9cfe55.webp )

之前一对多关系是通过在多的一方添加外键来引用一的一方的 id。

![](./images/3b63d76f9f0e6bcf342a26715bee00da.webp )

但是现在是多对多了，每一方都是多的一方。这时候是不是双方都要添加外键呢？

一般我们是这样设计：

![](./images/efd807349b0efb67c366f751f32977cf.webp )

文章一个表、标签一个表，这两个表都不保存外键，然后添加一个中间表来保存双方的外键。

这样文章和标签的关联关系就都被保存到了这个中间表里。

我们试一下：

这次我们就直接通过 sql 建表了：

```sql
CREATE TABLE `article` (
 `id` INT NOT NULL AUTO_INCREMENT,
 `title` VARCHAR(50) NOT NULL,
 `content` TEXT NOT NULL,
 PRIMARY KEY (`id`)
) CHARSET=utf8mb4;
```

这里的 TEXT 是长文本类型，可以存储 65535 长度的字符串。

执行这个建表 sql：

![](./images/24676f19ffbfa433811ed9a4043a89d6.webp )

查询下：

![](./images/c8002891c54483e6f19dc1fc76032f25.webp )

插入几条数据：

```sql
INSERT INTO `article` (`title`, `content`)
    VALUES
            ('文章1', '这是文章1的内容。'),
            ('文章2', '这是文章2的内容。'),
            ('文章3', '这是文章3的内容。'),
            ('文章4', '这是文章4的内容。'),
            ('文章5', '这是文章5的内容。');
```

![](./images/ae65851d85c37d9c193f10b4bee5ef3c.webp )

再查询下：

![](./images/479e5a87f28bac8143bce0432f296099.webp )

然后创建标签表：

```sql
CREATE TABLE `tag` (
 `id` INT NOT NULL AUTO_INCREMENT,
 `name` VARCHAR(50) NOT NULL,
 PRIMARY KEY (`id`)
);
```

![](./images/a9bc3a3d5be63ce26293fa7697af003b.webp )

插入几条数据：

```sql
INSERT INTO `tag` (`name`)
    VALUES
            ('标签1'),
            ('标签2'),
            ('标签3'),
            ('标签4'),
            ('标签5');
```

![](./images/f52091c30160d7b2540a4a222441f5d3.webp )

然后查询下：

![](./images/f11df2e1e928197e916d7fc2986e31f6.webp )

可以看到，建表和插入数据都成功了。

然后创建中间表：

中间表还是通过可视化的方式创建吧：

![](./images/89372a0d7cc288a4f4b32b76f000845e.webp )

点击创建表，添加 article\_id、tag\_id 这俩列，设置为 NOT NULL。

注意，这里同时指定这两列为 primary key，也就是复合主键。

添加 article\_id 和 tag\_id 的外键引用：

![](./images/a1dc70356774fe6b3165d5ceda09e81c.webp )

![](./images/248cf5b085117f67bfbf997d4a4e2c7e.webp )

**中间表的级联方式要设置为 CASCADE，这个是固定的。**

因为它就是用来保存关系的，如果关联的记录都没了，这个关系也就没存在的意义了。

点击 apply，可以看到生成的 sql：

![](./images/f439330f65cec61cff19987b1e3a5ee8.webp )

primary key (article\_id, tag\_id) 是指定复合主键。

后面分别是添加两个外键约束。

建表 sql 能看懂即可，不需要手写。

然后插入几条数据：

```sql
INSERT INTO `article_tag` (`article_id`, `tag_id`)
    VALUES
    (1,1), (1,2), (1,3),
    (2,2), (2,3), (2,4),
    (3,3), (3,4), (3,5),
    (4,4), (4,5), (4,1),
    (5,5), (5,1), (5,2);
```

点击左上角按钮，新建一条 sql：

![](./images/27c4e9f793a5b83d19a584a9b39db99c.webp )

输入 sql 后点击执行。

然后就可以看到插入的数据了：

![](./images/646995492c5cfc7392820e01347d2329.webp )

那现在有了 article、tag、article\_tag 3 个表了，怎么关联查询呢？

JOIN 3 个表呀！

```sql
SELECT * FROM article a 
    JOIN article_tag at ON a.id = at.article_id
    JOIN tag t ON t.id = at.tag_id
    WHERE a.id = 1
```

这样查询出的就是 id 为 1 的 article 的所有标签：

![](./images/8f433c5e2ea2da759d32ef403c0bdb56.webp )

当然，一般我们会指定返回的列：

```sql
SELECT t.name AS 标签名, a.title AS 文章标题
    FROM article a 
    JOIN article_tag at ON a.id = at.article_id
    JOIN tag t ON t.id = at.tag_id
    WHERE a.id = 1
```

![](./images/8db19e648bd739c0d20b17f23105ca96.webp )

此外，我们把文章1 删除试试：

选中这条 sql 执行：

```sql
delete from article where id = 1;
```

![](./images/fa8cf86ff7d594b850c6ae7ccdf9d9ef.webp )

然后再执行下面的查询：

![](./images/509dd49166d1325b9d01b72816bc22f8.webp )

可以看到关系也被级联删除了，这就是 CASCADE 的作用。

当然，删除的只是关系，并不影响 id=1 的标签：

![](./images/e450bda807583f0c54e149b032769371.webp )

这就是多对多数据的表设计、关联查询和级联方式。

## 总结

现实生活中有很多的一对多、多对多关系。

我们创建了部门、员工表，并在员工表添加了引用部门 id 的外键 department\_id 来保存这种一堆多关系。

并且设置了级联方式为 set null。

创建了文章表、标签表、文章标签表来保存多堆多关系，多对多不需要在双方保存彼此的外键，只要在中间表里维护这种关系即可。

中间表的外键级联方式一定为 CASCADE，因为数据没了关系就没必要还留着了。

此外，多对多的 join 需要连接 3 个表来查询。

一对多、多对多是非常常见的表之间的关系，要好好掌握它们的外键设置、关联查询、级联方式。
