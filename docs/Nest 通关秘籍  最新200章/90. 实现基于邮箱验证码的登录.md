# 90. 实现基于邮箱验证码的登录

上节我们学习了用 Node 来收发邮件，其实 Node 发邮件最常见的场景还是邮箱验证码。

比如登录的时候除了可以通过用户名、密码来验证身份，还可以通过邮箱验证码来验证。

这节我们就实现下这个功能。

首先，我们写个简单的登录页面:

通过 create-react-app 创建个项目：

```
npx create-react-app email-login-frontend
```
然后进入项目把开发服务跑起来：

```
npm run start
```

![](./images/625bd05df63a6b3bcc52290c1fc85498.webp )

![](./images/00bf49cf698886a671732fc55864b696.webp )

安装 antd：

```
npm install antd --save
```

然后来写下登录 UI：

```javascript
import React from 'react';
import { Button, Form, Input } from 'antd';

const login = (values) => {
  console.log('Success:', values);
};

const sendEmailCode = () => {
  console.log('send email code')
}

const App = () => (
  <div style={{width: '500px', margin: '100px auto'}}>
    <Form onFinish={login}>

      <Form.Item
        label="邮箱"
        name="email"
        rules={[
          {
            required: true,
            message: '请输入邮箱地址',
          },
        ]}
      >
        <Input />
      </Form.Item>

      <Form.Item
        label="验证码"
        name="code"
        rules={[
          {
            required: true,
            message: '请输入验证码',
          },
        ]}
      >
        <Input/>
      </Form.Item>

      <Form.Item>
        <Button onClick={sendEmailCode}>发送验证码</Button>
      </Form.Item>

      <Form.Item>
        <Button type="primary" htmlType="submit">登录</Button>
      </Form.Item>

    </Form>
  </div>
);
export default App;
```
在 App.js 输入上面的代码，就可以看到登录页面：

![](./images/ac25255907d3cf896e4ff078a44d3d82.webp )

比较丑，但功能是没问题的：

![](./images/05ba72f1e077abf0bd207e541a7e387f.webp )

然后我们再来写下后端代码。

创建个 nest 项目：

```
nest new email-login-backend -p npm
```
![](./images/9fc0afe252c13bf9d4270dd045170b20.webp )

在 main.ts 启用跨域，并且修改下端口号（因为前端项目开发服务也用这个端口号）：

![](./images/c85f5ac6744f1ff8bf30ec2d597f2d48.webp )

然后跑起来：

```
npm run start:dev
```
浏览器访问可以看到 hello world 代表 nest 服务跑成功了：

![](./images/92a32ed7fb63beb108d369dab68776b0.webp )

然后在前端项目里访问下。

在前端项目安装 axios：

```
npm install --save axios
```

然后调用下接口：

```javascript
import axios from 'axios';

const login = (values) => {
  console.log('Success:', values);
};

const sendEmailCode = async () => {
  const res = await axios.get('http://localhost:3001');

  console.log(res);
  console.log('send email code')
}
```
试一下：

![](./images/7832fb83d541c39c46a746ccb859abb8.webp )

接口调通了。

然后回到后端项目，我们继续写后端接口：

创建 user 模块：

```
nest g resource user
```
![](./images/0d3785eb95f1f880af2490d812a2dab3.webp )

安装 typeorm 的依赖：
```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserModule } from './user/user.module';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "email_login_test",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后我们在 mysql workbench 创建个新的 database：

![](./images/83fab932a2825e7fadad15f52d0f5733.webp )

输入 database 或者叫 schema 的名字，指定字符集为 utf8mb4。

点击 apply 可以看到生成的 sql：

![](./images/d7cb7890c0e2ecb6e5e579a38ba201d8.webp )

改下 User 的 entity：

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class User {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50,
        comment: '用户名'
    })
    username: string;

    @Column({
        length: 50,
        comment: '密码'
    })
    password: string;

    @Column({
        length: 50,
        comment: '邮箱地址'
    }) 
    email: string;
}
```
user 表有 id、username、password、email 这 4 个字段。

在 TypeOrm 的 entities 注册下：

![](./images/a99a67e0fc8f637f405f526877ac8b51.webp )

保存，nest 服务会自动重新跑：

![](./images/8e716811f45fe8131fa67073256599eb.webp )

可以看到 user 表被创建了。

![](./images/4cc52855accd1fe731ff1d5f491c3367.webp )

这次我们手动插入下数据：

![](./images/aa098776ede7cf15be19f2ca5916953b.webp )

输入内容后，点击 apply，可以看到生成的 sql：

![](./images/9ea5669d1d271dfa32bf655f9bad7398.webp )

你直接执行这个 sql 来插入数据也行：

```sql
INSERT INTO `email_login_test`.`user` 
  (`id`, `username`, `password`, `email`) 
  VALUES ('1', 'aaaa', 'bbbb', 'xxx@xx.com');
```

这里邮箱要改成你自己的，因为待会要发邮件用。

之后来添加下发邮件的接口。

添加个 email 模块，这次不用生成 crud 代码了：

```
nest g resource email
```
![](./images/ba622f29b9acae52df5351f1c0efc98e.webp )

![](./images/07fadabd660b6dd283e18c376bb621c1.webp )

然后我们安装 nodemailer 包来发邮件：

```
npm install --save nodemailer

npm install --save-dev @types/nodemailer
```

在 MailService 里来发邮件：

```javascript
import { Injectable } from '@nestjs/common';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor() {
        this.transporter = createTransport({
            host: "smtp.qq.com",
            port: 587,
            secure: false,
            auth: {
                user: 'xx@xx.com',
                pass: '你的授权码'
            },
        });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '系统邮件',
          address: 'xx@xx.com'
        },
        to,
        subject,
        html
      });
    }
}
```

把邮箱和授权码改成你自己的。

然后添加一个 controller 方法：

```javascript
import { Controller, Get, Query } from '@nestjs/common';
import { EmailService } from './email.service';

@Controller('email')
export class EmailController {
  constructor(private readonly emailService: EmailService) {}

  @Get('code')
  async sendEmailCode(@Query("address") address) {
    await this.emailService.sendMail({
      to: address,
      subject: '登录验证码',
      html: '<p>你的登录验证码是 123456</p>'
    });
    return '发送成功';
  }
}

```
我们调用下试试：

![](./images/0496b10a67e6e6fbe8d236825f432405.webp )

发送成功，邮箱里确实也收到了这封邮件：

![](./images/3c8165972fd1d6a5cb0d901a6cd3116b.webp )

![](./images/9cb338effbfc71bf4ded5fb829ec9b98.webp )

回过头来看一下，我们现在是把邮箱相关信息直接写在代码里了。

![](./images/47c7c966f871b4065071f1c6f821948d.webp )

实际上这些应该从配置读取。

我们安装下配置模块：

```
npm install --save @nestjs/config
```
在 AppModule 里引入，并且把它声明为全局的：

![](./images/129a1daf61b611ffd1ad90fd0dfa3d5a.webp )

```javascript
ConfigModule.forRoot({
    isGlobal: true,
    envFilePath: 'src/.env'
})
```
在 src 下添加这个 .env 文件：

![](./images/5e43797aad48062ee6130686c8d6afea.webp )

然后在 EmailService 里注入 ConfigService，从中读取配置：

![](./images/acd2b42d62d487b2763525e1d7082bf4.webp )

```javascript
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor(private configService: ConfigService) {
      this.transporter = createTransport({
          host: "smtp.qq.com",
          port: 587,
          secure: false,
          auth: {
              user: this.configService.get('email_user'),
              pass: this.configService.get('email_password')
          },
      });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '系统邮件',
          address: this.configService.get('email_user')
        },
        to,
        subject,
        html
      });
    }

}

```
再调用下接口，这时依然是正常的：

![](./images/8c4218255bd69169c1001037d52f52eb.webp )

![](./images/02d76931bb08a57943428c65bd1b8f4c.webp )

说明配置正确读取出来了。

不过用了 .env 配置文件之后有个问题：

![](./images/0c5d0efc9c8b54ded2f8f3c19515d9e7.webp )

dist 目录下没有这个文件。

.env 需要配置下 assets 才会复制过去。

改下 nest-cli.json

![](./images/f83cb21068f53a1fe9e8c4ec2c14bd8f.webp )

添加 assets 为 \*.env 这样就会在编译的时候把 src 下的 .env 文件复制到 dist 下。

注意，**assets 只支持 src 下的文件复制**。如果你是放在根目录，那就要自己复制了。

改了编译配置需要重新跑服务：

```
npm run start:dev
```
![](./images/0a609f87412e1c4b9aedae041a9494a8.webp )

这时就可以在 dist 下看到这个文件了。

但现在你改了 src 下的 .env 之后，dist 下的 .env 不会跟着改，需要重新跑服务才可以。

![](./images/16078ebef565ddbf63192a65fd4e1c6e.webp )

这时候可以加一个 watchAssets：

![](./images/284767dc40cef98967324305e5e6bee9.webp )

然后再重新跑下服务。

![](./images/1a79e3bd3f1c6cb4352364d230b36f1c.webp )

这时候改了 src 下的 .env 就会立刻复制了。

也就是说，**如果你用到了 .env 文件或者 yaml 等文件来配置，需要在 nest-cli.json 里配置下 assets 和 watchAssets。**

回过头来继续搞验证码的事情。

首先，验证码要随机，我们通过 Math.random 来生成：

![](./images/ed22fdb0b27c861b1d75f6a16c477b82.webp )

```javascript
const code = Math.random().toString().slice(2,8);
````
![](./images/7d84e041aaee399136cf45d648182fcc.webp )

然后在前端项目里调用下看看：

![](./images/07155862b8b676d58be2d19af58ffcd5.webp )

通过 useForm 创建 form 实例，然后就可以通过 form.getFieldsValue 拿到表单值了：

![](./images/2db93dbdb33111f5e4846c4073931f47.webp )

```javascript
import React from 'react';
import { Button, Form, Input } from 'antd';
import axios from 'axios';

const login = (values) => {
  console.log('Success:', values);
};

const App = () => {
  const [form] = Form.useForm();

  const sendEmailCode = async () => {
    const res = await axios.get('http://localhost:3001');
  
    console.log(form.getFieldsValue());

    console.log(res);
    console.log('send email code')
  }
  

  return <div style={{width: '500px', margin: '100px auto'}}>
    <Form form={form} onFinish={login}>

      <Form.Item
        label="邮箱"
        name="email"
        rules={[
          {
            required: true,
            message: '请输入邮箱地址',
          },
        ]}
      >
        <Input />
      </Form.Item>

      <Form.Item
        label="验证码"
        name="code"
        rules={[
          {
            required: true,
            message: '请输入验证码',
          },
        ]}
      >
        <Input/>
      </Form.Item>

      <Form.Item>
        <Button onClick={sendEmailCode}>发送验证码</Button>
      </Form.Item>

      <Form.Item>
        <Button type="primary" htmlType="submit">登录</Button>
      </Form.Item>

    </Form>
  </div>
};
export default App;
```

在点击发送验证码的时候，验证下邮箱是否为空，不为空就调用后端接口来发送验证码：

```javascript
import { message } from 'antd';

const App = () => {
  const [form] = Form.useForm();

  const sendEmailCode = async () => {
    const email = form.getFieldValue('email');
    
    console.log(email)
    if(!email) {
      message.error('邮箱不能为空');
      return;
    }

    const res = await axios.get('http://localhost:3001/email/code', {
      params: {
        address: email
      }
    });
  
    message.info(res.data);
  }
  
```

我们来试试看：

![](./images/4a79ecedd0bf1355c7fdfc686ca7e099.webp )

点击发送验证码，这个邮箱收到了一封验证码的邮件：

![](./images/e125e9b0d2adb044697fcc665744f15d.webp )

然后我们来实现下登录。

登录就是根据用户填的信息去数据库匹配，如果匹配到了就查询出该用户的信息，放入 session 或者 jwt 里。

![](./images/4e38ece0b593e0c084448d592b08d923.webp )

验证用户身份的信息，可以是用户名 + 密码，也可以是邮箱 + 验证码。
    
用邮箱验证码验证用户身份的流程是这样的：

![](./images/4401751dc56bfb4e4eab154985ae1936.webp )

用户填入邮箱地址，点击发送验证码，后端会生成验证码，发送邮件。并且还要把这个验证码存入 redis，以用户邮箱地址为 key。

之后用户输入验证码，点击登录。

后端根据邮箱地址去 redis 中查询下验证码，和用户传过来的验证码比对下，如果一致，就从 mysql 数据库中查询该用户的信息，放入 jwt 中返回。

思路理清了，我们来实现下：

创建个 redis 模块：

```
nest g resource redis  --no-spec
```

![](./images/188202ceab3c16809780f17a22ac40eb.webp )

安装 redis 的包：
```
npm install redis --save
```

把 RedisModule 声明为全局模块，并导出 RedisService。

然后添加一个 provider：

```javascript
import { Global, Module } from '@nestjs/common';
import { RedisService } from './redis.service';
import { RedisController } from './redis.controller';
import { createClient } from 'redis';

@Global()
@Module({
  controllers: [RedisController],
  providers: [RedisService, {
    provide: 'REDIS_CLIENT',
    async useFactory() {
      const client = createClient({
          socket: {
              host: 'localhost',
              port: 6379
          }
      });
      await client.connect();
      return client;
    }
  }],
  exports: [RedisService]
})
export class RedisModule {}

```

在 RedisService 里封装 redis 的 get、set 方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async get(key: string) {
        return await this.redisClient.get(key);
    }

    async set(key: string, value: string | number, ttl?: number) {
        await this.redisClient.set(key, value);

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```

然后修改下发送邮箱验证码的逻辑：

![](./images/34639f004604fcb209c62a1b14c17c04.webp )

注入 RedisService，并且发送验证码之前把它存入 redis，key 为 captcha_邮箱地址。

这里的 captcha 就是验证码的意思。

过期时间为 5 分钟。

```javascript
import { Controller, Get, Inject, Query } from '@nestjs/common';
import { RedisService } from 'src/redis/redis.service';
import { EmailService } from './email.service';

@Controller('email')
export class EmailController {
  constructor(private readonly emailService: EmailService) {}

  @Inject()
  private redisService: RedisService;

  @Get('code')
  async sendEmailCode(@Query("address") address) {
    const code = Math.random().toString().slice(2,8);

    await this.redisService.set(`captcha_${address}`, code, 5 * 60);

    await this.emailService.sendMail({
      to: address,
      subject: '登录验证码',
      html: `<p>你的登录验证码是 ${code}</p>`
    });
    return '发送成功';
  }
}
```

我们试试看：

![](./images/7fcd73cc6db9b6c5f9c0b47852647d72.webp )

输入邮箱地址，点击发送验证码。

邮箱收到了这个验证码：

![](./images/6c878a494cd6fcc475b21a716ef0b2e7.webp )

redis 里也保存了一份：

![](./images/5f64c8a223d9215b5166558ecf9f137e.webp )

接下来只要填入这个验证码，点击登录就可以了：

![](./images/5de9a573200c870a80eb27473ce758f5.webp )

我们再来实现下登录接口：

在 UserController 里添加一个路由：

```javascript
@Post('login')
login(@Body() loginUserDto: LoginUserDto) {
    console.log(loginUserDto);
    return 'success';
}
```
定义这个 LoginUserDto：

![](./images/45d45de65a92659ef5dc79301b415895.webp )

然后需要对它做校验，我们引入 class-validator 和 class-transformer：

```
npm install --save class-validator class-transformer
```
在 main.ts 里全局启用 ValidationPipe：

![](./images/becc34c10825591537f191c1be797192.webp )

然后给 LoginUserDto 添加一些约束：

```javascript
import { IsEmail, IsNotEmpty, Length } from "class-validator";

export class LoginUserDto {
    @IsNotEmpty()
    @IsEmail()
    email: string;

    @IsNotEmpty()
    @Length(6)
    code: string;
}
```
在 postman 里测试下：

![](./images/5a74d066a4485f6dca742b764b802c53.webp )

![](./images/a39093ee4a9c31e6e9946ea25fee410d.webp )

没啥问题。

我们来实现下具体的验证逻辑:

```javascript
@Inject(RedisService)
private redisService: RedisService;

@Post('login')
async login(@Body() loginUserDto: LoginUserDto) {

    const { email, code } = loginUserDto;

    const codeInRedis = await this.redisService.get(`captcha_${email}`);

    if(!codeInRedis) {
      throw new UnauthorizedException('验证码已失效');
    }
    if(code !== codeInRedis) {
      throw new UnauthorizedException('验证码不正确');
    }

    const user = await this.userService.findUserByEmail(email);

    console.log(user);

    return 'success';
}
```
从 redis 中查找这个邮箱对应的验证码。

如果没查找，就返回验证码已失效。

查到的话和用户传过来的验证码对比，如果不一致，就返回验证码不正确。

验证码通过之后，从数据库中查询这个用户的信息。

我们在 UserService 里实现下这个方法：

```javascript
@InjectEntityManager()
private entityManager: EntityManager;

async findUserByEmail(email: string) {
    return await this.entityManager.findOneBy(User, {
      email
    });
}
```
然后在前端代码里调用下：

```javascript
const login = async (values) => {
  const res = await axios.post('http://localhost:3001/user/login', {
    email: values.email,
    code: values.code
  });
  if(res.data === 'success') {
    message.success('登录成功');
  } else {
    message.error(res.data.message);
  }
};
```
我们整体试一下：


![](./images/a90b8ce45ff938061c4794165377d8f9.webp )

输入邮箱，点击发送验证码。

![](./images/f03283625bb8612f6bc529327570c049.webp )

收到了验证码邮件，并且 redis 里也存了这个 key：

![](./images/6a201f8b7d4caad9ce1b2777544c69c2.webp )

带上这个验证码请求：

![](./images/5d61bae81381c682223652ccf5670b8a.webp )

可以看到服务端通过了校验，并且从数据库中查询出了用户信息：

![](./images/ff8d0680f5e348697bc117c920852f92.webp )

接下来只要返回对应的 jwt token 就好了。

这部分可以参考前面 jwt 登录章节的内容，就不展开了。

案例代码上传了小册仓库：

[前端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/email-login-frontend)

[后端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/email-login-backend)

## 总结

这节我们实现了基于邮箱验证码的登录。

流程可以看这张图：

![](./images/0cc9d6087c85ecc1b3dfa19327c851e5.webp )

综合用到了 mysql、redis、typeorm、nodemailer 等技术。

并且使用 @nestjs/config 包的 ConfigModule 来封装配置。

要注意的是，如果用了 .env 文件，需要保证它在 src 下，并且要在 nest-cli.json 里配置 assets 和 watchAssets，不然 build 的时候不会复制到 dist 下。

这节实现的功能，前后端代码都有，算是一个不错的综合练习。
