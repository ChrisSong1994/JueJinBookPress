# 115. 会议室预订系统：用户管理模块-- swagger 接口文档

后端写完接口，都会提供一份接口文档给前端。

这节我们就来做下这件事情，通过 swagger 生成接口文档。

安装 swagger 的包：

```
npm install --save @nestjs/swagger
```
在 main.ts 添加这段代码：

![](./images/5e756a99c70fd0c9a58d9f6a0d18a9d0.png )

```javascript
const config = new DocumentBuilder()
    .setTitle('会议室预订系统')
    .setDescription('api 接口文档')
    .setVersion('1.0')
    .build();
const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('api-doc', app, document);
```
用 SwaggerModule 生成接口文档，url 是 /api-doc

访问下：

![](./images/e6efc93b7642b5d584af32ab28f78fa7.png )

可以看到所有接口都列出来了：

![](./images/40054d10f1a28e5ef45dda0d3c4ef16f.png )

还有用到的 schema，也就是对象的结构：

![](./images/e8093c8bac760a6229b1353467909f3c.png )

只不过很多接口的文档是不对的：

比如用户列表接口，这些参数都不是必选的，而且也没有响应相关的信息：

![](./images/8387d57e5df7cf78757cf54a6d5a84a0.png )

还有 schema 也没有具体的内容。

这些需要我们加一些装饰器来告诉 swagger。

在 UserController 添加一个 @ApiTags

![](./images/2506fd387ad650792a17ec5b61b927b1.png )

这样这个 cotroller 的接口会被单独分组：

![](./images/b511a49fa9ecef0a5d9c6cea66885dd6.png )

然后我们一个个接口来看：

![](./images/e2bc8c6cd33ede5ae6979af107a25985.png )

先是 /user/register-captcha 接口

![](./images/0f50d4250dd2a104e3fa7ff0f363ac6e.png )

```javascript
@ApiQuery({
    name: 'address',
    type: String,
    description: '邮箱地址',
    required: true,
    example: 'xxx@xx.com'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '发送成功',
    type: String
})
```
通过 @ApiQuery 描述 query 参数，通过 @ApiResponse 描述响应。

![](./images/6a4b96264d017ffcb192c1300d388a8e.png )

然后是 /user/register 接口：

它一共有 2 种状态码，200 和 400：

![](./images/47b1cca944e08f62eb60bbd36daf5569.png )

![](./images/b6708bb8741f8ee73f478b6e72a30c84.png )

```javascript
@ApiBody({type: RegisterUserDto})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '验证码已失效/验证码不正确/用户已存在',
    type: String
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '注册成功/失败',
    type: String
})
```

![](./images/a31a0c10584bd7f8c14e4670e76e34fc.png )

请求体的属性需要去 dto 里标识：

![](./images/5460fffdc0cc124692ebd8c16bb46b33.png )

![](./images/c3f7b2601adba12c56eb524864c6e3f6.png )

然后接口文档里就可看到请求体的信息了：

![](./images/ebb0643bfe42c2fcfdd9fd1da64fba53.png )

下面的 schema 里的 RegisterUserDto 也有了内容：

![](./images/3eb949c09234935d3825f56b77512161.png )

接下来是 /user/login 接口：

它也是有 400 和 200 两种响应：

![](./images/ba44690c1bfa69ef2c31772d25e09131.png )

![](./images/beb71c531608857844d26085f42f0277.png )

```javascript
@ApiBody({
    type: LoginUserDto
})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '用户不存在/密码错误',
    type: String
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '用户信息和 token',
    type: LoginUserVo
})
```
通过 @ApiResponse 标识两种响应，通过 @ApiBody 标识请求体。

然后在 LoginUserDto 和 LoginUserVo 里标识下属性：

LoginUserDto：
![](./images/bfe7dcfe869d67006816b2465e7a1189.png )

LoginuserVo：

```javascript
import { ApiProperty } from "@nestjs/swagger";

class UserInfo {
    @ApiProperty()
    id: number;

    @ApiProperty({example: 'zhangsan'})
    username: string;

    @ApiProperty({example: '张三'})
    nickName: string;

    @ApiProperty({example: 'xx@xx.com'})
    email: string;

    @ApiProperty({example: 'xxx.png'})
    headPic: string;

    @ApiProperty({example: '13233333333'})
    phoneNumber: string;

    @ApiProperty()
    isFrozen: boolean;

    @ApiProperty()
    isAdmin: boolean;

    @ApiProperty()
    createTime: number;

    @ApiProperty({example: ['管理员']})
    roles: string[];

    @ApiProperty({example: 'query_aaa'})
    permissions: string[]
}
export class LoginUserVo {

    @ApiProperty()
    userInfo: UserInfo;

    @ApiProperty()
    accessToken: string;

    @ApiProperty()
    refreshToken: string;
}
```

之前这里的 UserInfo 是 interface，这里要改成 class 才能加装饰器。

测试下：

![](./images/be04f623660eb40b946433bcc0594c91.png )

![](./images/70fc2b9b85078451244f1d4d57dd5e6e.png )

/user/admin/login 的 swagger 装饰器和 /user/login 一样。

然后继续看 /user/refresh 接口：

![](./images/579380468e46c2bb619e9160c48b43c6.png )
```javascript
@ApiQuery({
    name: 'refreshToken',
    type: String,
    description: '刷新 token',
    required: true,
    example: 'xxxxxxxxyyyyyyyyzzzzz'
})
@ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'token 已失效，请重新登录'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '刷新成功'
})
```

用 @ApiQuery 标识 query 参数，用 @ApiResponse 标识两种响应。

![](./images/c122c8d2a620eeef0a865f5148fb4fe9.png )
 
但现在刷新成功的 access_token 和 refresh_token 没有显示。

所以我们也需要把这个返回值封装成 vo：

![](./images/bc2177f9299560a75e9765960c67ab1e.png )

新建 src/user/vo/refresh-token.vo.ts

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class RefreshTokenVo {
    @ApiProperty()
    access_token: string;

    @ApiProperty()
    refresh_token: string;
}
```
把返回的结果封装成 vo：

![](./images/691f35c9fd9f0d0e4d5f69a265ad1e22.png )

```javascript
const vo = new RefreshTokenVo();

vo.access_token = access_token;
vo.refresh_token = refresh_token;

return vo;
```
在 @ApiResponse 里标识这个 type

![](./images/ef5f9534344987952918b6256c5bf89a.png )

刷新下页面，可以看到现在接口文档里就有了返回数据的结构：

![](./images/d863b921fc26c566f0132f37f5713dca.png )

/user/admin/login 的处理方式一样。

接下来是 /user/info 接口：

![](./images/b0fefa4d081bb74aeb83964b62a11a28.png )

加一下返回的数据的标识 @ApiResponse。

然后在 UserDetailVo 里加一下 @ApiProperty：

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class UserDetailVo {
    @ApiProperty()
    id: number;

    @ApiProperty()
    username: string;

    @ApiProperty()
    nickName: string;

    @ApiProperty()
    email: string;

    @ApiProperty()
    headPic: string;

    @ApiProperty()
    phoneNumber: string;

    @ApiProperty()
    isFrozen: boolean;

    @ApiProperty()
    createTime: Date;
}
```
这样返回的数据结构就对了：

![](./images/8dc123840a5dd0d0e7af66212436f14e.png )

但这个接口是需要登录的，我们加一下标识：

![](./images/005da6855941e4afee907a89b02c2f68.png )

然后在 main.ts 里加一下这种 bearer 的认证方式：

![](./images/4bdbe15d4d91324e1415ba4e236385e1.png )

这时候这个接口就有了锁的标记，代表需要登录了：

![](./images/6fc2be89b16a3f9826f9250125d2571c.png )

点击锁，填入 access_token，这样再测试接口的时候，会自动带上 token 标识：

![](./images/80291b7624055d88285d602617cd8a97.png )

比如我输入 xxx，然后点击 authorize

然后点击 try it out 和 execute，可以看到浏览器发送了这个请求，并且带上了 authorization 的 header 

![](./images/10cfeb3ef6c42c94d7afdb6c95c3feda.png )

可以在 swagger 文档里测试这个接口。

接下来是 /user/update_password

![](./images/3970275c0e06fe98ff8c8924fa30d6c1.png )

```javascript
@ApiBearerAuth()
@ApiBody({
    type: UpdateUserPasswordDto
})
@ApiResponse({
    type: String,
    description: '验证码已失效/不正确'
})
```
在 UpdateUserPasswordDto 里加一下 @ApiProperty

![](./images/8dd9d85dab53614790e324bc9d435400.png )
接口文档没啥问题：

![](./images/f8327699b414698e9593f0bf3138414b.png )

接下来是 /user/update_password/captcha 接口

![](./images/1f892f8765d6384ea19fc463ca23d707.png )

这个接口是需要登录的，当时为了测试方便没有加，现在加一下：

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'address',
    description: '邮箱地址',
    type: String
})
@ApiResponse({
    type: String,
    description: '发送成功'
})
@RequireLogin()
```

![](./images/012268cfe8ffb6385fbae233f100dc9f.png )

然后是 /user/update 接口：

![](./images/3063430e7dcdb0b63c8b1c17471e1409.png )
```javascript
@ApiBearerAuth()
@ApiBody({
    type: UpdateUserDto
})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '验证码已失效/不正确'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '更新成功',
    type: String
})
```
在 UpdateUserDto 里标识下 @ApiProperty
 
![](./images/91ad11a60a04d27ea983c7091eb1ea61.png )

刷新下，可以看到最新的接口文档：

![](./images/2845ebd5b5c67899b04b1ad3b3b5eb14.png )

然后是 /user/freeeze 接口

![](./images/5ea97efe5e2aaae8eb2d94d0b494a939.png )

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'id',
    description: 'userId',
    type: Number
})
@ApiResponse({
    type: String,
    description: 'success'
})
@RequireLogin()
```

刷新下：

![](./images/030d941b193a676284396b55bf6660ab.png )

没啥问题。

最后，还剩下 /user/list 接口：

![](./images/6f7c056144049ad6ee11d9bbedaee5ff.png )

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'pageNo',
    description: '第几页',
    type: Number
})
@ApiQuery({
    name: 'pageSize',
    description: '每页多少条',
    type: Number
})
@ApiQuery({
    name: 'username',
    description: '用户名',
    type: Number
})
@ApiQuery({
    name: 'nickName',
    description: '昵称',
    type: Number
})
@ApiQuery({
    name: 'email',
    description: '邮箱地址',
    type: Number
})
@ApiResponse({
    type: String,
    description: '用户列表'
})
@RequireLogin()
```
这里的返回值需要封装个 vo：

![](./images/3af5623b196acce66eb2071bfade0488.png )

创建 src/user/vo/user-list.vo.ts
```javascript
import { ApiProperty } from "@nestjs/swagger";

class User {
    @ApiProperty()
    id: number;

    @ApiProperty()
    username: string;

    @ApiProperty()
    nickName: string;
    
    @ApiProperty()
    email: string; 

    @ApiProperty()
    phoneNumber: string;

    @ApiProperty()
    isFrozen: boolean;
    
    @ApiProperty()
    headPic: string;

    @ApiProperty()
    createTime: Date;
}

export class UserListVo {

    @ApiProperty({
        type: [User]
    })
    users: User[];

    @ApiProperty()
    totalCount: number;
}
```

注意这里标识 User 数组要用 [User]

然后把 findUsers 的返回值改为 UserListVo

![](./images/07bcb9a31259d20c02ef412d0f9b2477.png )

```javascript
const vo = new UserListVo();

vo.users = users;
vo.totalCount = totalCount;
return vo;
```

刷新下接口文档：

![](./images/48ea25f7398d7fb37ada1f9c3a003bf1.png )

![](./images/f525137c3a9026d4398fff55b964cb30.png )

没啥问题。

这样，我们就给所有的接口生成了 api 文档。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们用 swagger 生成了接口文档。

在 main.ts 里调用 SwaggerModule.setup 来生成接口文档。

然后用 @ApiQuery、@ApiBody、@ApiResponse、@ApiProperty 等来标识每个接口的参数和响应。

并且通过 @ApiBearerAuth 标识需要 jwt 认证的接口。

返回对象的接口需要把它封装成 vo，然后再添加 @ApiProperty。

接口文档提供给前端之后，前端就可以基于这个来写页面了。


