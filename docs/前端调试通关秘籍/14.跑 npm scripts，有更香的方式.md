# 14.跑 npm scripts，有更香的方式

每个前端项目都有 npm scripts，我们会用 npm scripts 来组织编译、打包、lint 等任务。

大家可能经常会跑 npm scripts，但却对这些命令行工具是怎么实现的并不了解。

那如果想了解这些工具的实现原理，应该怎么做呢？

这就是今天的主题：调试 npm scripts。

这些命令行工具的 package.json 里都会有个 bin 字段，来声明有哪些命令：

![](./images/e38521390fd81b4254036d7d8d9318c3.webp )

npm install 这个包以后，就会放到 node_modules/.bin 目录下：

![](./images/543ccc5276ec230948acaeac9a3083fe.webp )

这样我们就可以通过 node ./node_modules/.bin/xx 来跑不同的工具了。

我们也可以用 npx 来跑，比如 npx xx，它的作用就是执行 node_modules/.bin 下的本地命令，如果没有的话会从 npm 下载然后执行。

当然，最常用的还是放到 npm scripts 里：

![](./images/a56bc021297fa4dc4778ef17e8838e7d.webp )

这样就直接 npm run xxx 跑就行了。

npm scripts 本质上还是用 node 来跑这些 script 代码，所以调试他们和调试其他 node 代码没啥区别。

也就是可以这样跑：

在 .vscode/launch.json 的调试文件里，选择 node 的 launch program：

![](./images/b961b9a8873bca3df29e04f6d1720b2e.webp )

用 node 执行 node_modules/.bin 下的文件，传入参数即可：

![](./images/42348bf7aa0d2d4f3eb31049684c3257.webp )

其实还有更简单的方式，VSCode Debugger 对 npm scripts 调试的场景做了封装，可以直接选择 npm 类型的调试配置：

![](./images/b22b51d8876a99fe168d2aaef4be2c06.webp )

直接指定运行的命令即可：

![](./images/c816e8c3e953c15de118f591bd27496c.webp )

比如我们就用这个 create-react-app 创建的 react 项目来尝试下 npm scripts 的调试：

先去 node_modules/.bin 下这个文件里打个断点：

![](./images/5fee8e48ae9f34ee0f8472682163c8e7.webp )
 
然后点击 debug 启动：

![](./images/2751550f152f5f59f0beb06c969d81a6.webp )

你会发现会执行 scripts 下的 start 模块：

![](./images/fec78ccc8d7e74ddd7c2922c0be038ce.webp )

我们再去 start 下打个断点：

代码执行到这里断住：

![](./images/e407820fff20e6b30bf2ae3c8329485c.webp )

这个 config 就是 webpack 的配置：

![](./images/5b9598c78caa3275c43089080c6c37f2.webp )

再往下走，会发现启动了一个 server：

![](./images/8b35f73602e388747c6544b91f322077.webp )

我们在 server 启动的回调函数里打个断点，看看浏览器是怎么打开的：

![](./images/1e1dae870648554c5423dc244e2db453.webp )

点击 step into 进入这个断点：

![](./images/484a6ffec3105af2f4260e16f4fb3b73.webp )

然后单步执行，会走到这样的代码：

依次通过 osascript 来启动这些浏览器，启动失败的话，try catch 里直接忽略了：

![](./images/8551ed31fa5aaae3e249cda8ef24e535.webp )

这些浏览器 hover 上去就可以看到：

![](./images/8735b0a38aa81411c468fb0d561abe9c.webp )

释放断点，你就会发现浏览器打开了：

![](./images/978f8df3d0817ad6c9d932d42052f578.webp )

这样，我们不就梳理了一遍 react-scripts start 的流程么？

总结一下就是这样的：

- 根据输入的 start 命令，执行 scripts/start 模块
- 根据配置，创建 webpack 的 Compiler 对象
- 创建 WebpackDevServer
- server 启动之后，启动浏览器打开 url
- 打开 url 的实现就是通过 osascripts 依次尝试那些浏览器

这样调试完一遍，我们就对 npm run start 有了更深入的认识。

而且，调试的方式跑 script 和直接命令行 npm run start 没啥区别。

要说区别，唯一的区别可能就是这个：

默认调试模式下，输出的内容会在 Debug Console 面板显示：

![](./images/11104e3230416342e477f378849b11ec.webp )

但这个也可以改：

![](./images/0ff689b4d3961fe8d425ddd55becf9a4.webp )

可以切换成 integratedTerminal，那就会输出在 terminal 了：

![](./images/77c371c22bd046f357592d15d99c583b.webp )

这样就和平时 npm run start 执行没了任何区别，而且还可以断点调试，它不香么？

我们再来看个例子，比如 vue cli 创建的 vue 项目，在 vue.config.js 里可以改 webpack 配置：

![](./images/6a9532f1e171ee4dc8c676ee856f5e0b.webp )

但如果你想知道默认的配置是啥呢？console.log 么？

console.log 打印大对象可不是个好主意，它是这样的：

![](./images/91784a674cae027148d82cd4e76a5bef.webp )

有的同学说用 JSON.stringify，那个更难看，特别长的一串。

如果你会了调试 npm scripts 呢？

你就可以加一个 npm 类型的调试配置：

![](./images/db23c8da966ad5ff6b31579b4480e0d5.webp )

然后打个断点，debug 来跑：

![](./images/2acf1a2e6ab5b976ae1801f715dc281e.webp )

啥配置都能看到，这不香么？

我举的例子只是 webpack 的，但其余的 npm scripts，比如 babel、tsc、eslint、vite 等等都是一样的调试方式。

## 总结

每个项目都有 npm scripts，大多数人只是用它们而不会调试它们，所以就算每天用也不知道这些工具的原理。

这些命令行工具都是在 package.json 中声明一个 bin 字段，然后 install 之后就会放到 node_modules/.bin 下。

可以 node node_modules/.bin/xx 来跑，可以 npx xx 来跑，最常用的还是 npm scripts，通过 npm run xx 来跑。

npm scripts 的调试就是 node 的调试，只不过 VSCode Debugger 做了简化，可以直接创建 npm 类型的调试配置。

把 console 配置为 integratedTerminal 之后，日志会输出到 terminal，和平时直接跑 npm run xx 就没区别了。而且还可以断点看看执行逻辑。

跑 npm scripts 之余，还可以理一下它的实现逻辑，哪里感兴趣断在哪里，这不比直接跑香么？