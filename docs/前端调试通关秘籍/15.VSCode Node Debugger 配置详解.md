# 15.VSCode Node Debugger 配置详解

前面两节我们学习了怎么调试 Node.js、npm scripts，这节我们来过一遍 VSCode Node Debugger 的常用配置。

首先，从 attch 的方式开始：

## attach

有这样一个 Node.js 文件：
```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({
    data: 'Hello World!'
  }));
});

server.listen(8888);
```
我们以调试模式启动：

![](./images/342c9dcc3189423974a2b15d72af60d7.webp )

然后 VSCode Debugger 添加一个 attach 类型的 Node 调试配置，端口是 9229:

![](./images/08a88a3ce6a32c232f16b749ac15b8ad.webp )

点击调试启动就可以连上。

打个断点：

![](./images/84856ecc4d69bb8cad41a082a782ce8b.webp )

浏览器访问，这时候代码就会在断点处断住：

![](./images/132d6da673747d51e90cba044fee274b.webp )

这些我们前面讲过，今天来讲一些别的配置：

### restart

VSCode Debugger 以 attach 的方式启动，是需要连接 ws 调试服务的，而连接自然就可能超时、失败之类的，这时候就需要重连。

重连的间隔和次数是可以配置的：

![](./images/64937a8b134cf3568962489276f14bea.webp )

比如上面就是 1s 重试一次，最多 3 次：

![](./images/abb9690218683126db85b69688e6c6ba.webp )

### attach by process id

上面的 attach 方式是连接到了 9229 端口，但其实还有另一种 attch 方式，就是通过进程 id。

比如上面跑在 9229 端口的 node 进程的 id 可以通过命令查看：

![](./images/713cb1a38e32f9022d137589b0e6db92.webp )

发现是 98700，那么我们就可以通过这个进程 id 来 attach 调试服务：

![](./images/6154ba07fc2e3dfb20e4a256e92719cd.webp )

![](./images/9f83ac1cdeca5e9020bd7e741627da4f.webp )

默认值是 ${command: PickProcess} 这个会弹出一个选择窗口：

![](./images/7a32c5c23582a807e9d92909ee12bfd4.webp )

选择 98700 的那个进程，attach 即可。

当然，这里我们已经知道了进程 id，那就不需要选择了，直接指定即可：

![](./images/09aedf3cd8083835c5d0a09c2c807c29.webp )

attch 的方式讲完了，接下来来看下 launch 方式的配置：

## launch

launch 不需要我们自己以调试模式启动，只需要指定 node 程序的地址即可：

### program & args

创建个 test 文件，打个断点：

![](./images/ba59a542836a46562d0a7f52936d04f0.webp )

添加一个 launch 类型的 Node 调试配置：

![](./images/e661f604f9bdbed4841876e252bc5f66.webp )

![](./images/ff865adaf1b0abef883c21377e99b25d.webp )

代码会在断点处断住，然后可以查看当前的命令行参数：

![](./images/c0c61972a177af59363da247ded455cb.webp )

命令行参数是这俩：

![](./images/5e11e82bef0227ff36153c154eb6ae9f.webp )

可以通过 args 来添加命令行参数：

![](./images/56a89db29e73b677d8681d5f5663fe03.webp )

![](./images/856b9cecfa1e439c8174d6c81c535316.webp )

### runtimeExecutable

runtime 默认是 node，其实这个也是可以改的：

![](./images/a191277f2c1681b0567af39c3e204ed2.webp )

VSCode Debugger 会从 PATH 的环境变量中查找对应名字的 runtime 启动。

我们前面调试 npm scripts，就是修改了这个：

![](./images/5fd128892a00807b5ef76f8c920f8814.webp )

比如我们可以跑 node 调试，是因为 PATH 中有 node。

我们可以安装一个 ts-node：

```
npm install -g ts-node
```

然后把 runtimeExecutable 改为 ts-node：

![](./images/523455a1cace3e58eb2bbd414ab2a7e1.webp )

这时候就是用 ts-node 来跑了：

![](./images/8661aefc29096b97e1c5a4e50056ccdc.webp )

你还可以通过 runtimeArgs 给它传参数。

VSCode 内置了 launch via npm 的配置，如果你把 runtimeExecutable 换成 pnpm，那就是 launch via pnpm 了。

![](./images/9dfd60a2c429f30784f690a45a712ceb.webp )

### skipFiles

这个配置的默认值是 <node_internal>/**

![](./images/8a322ecc5f8bd8b9ce279ad7aa033d1d.webp )

也就是跳过 node 内部的文件。

效果就是这样的：

![](./images/3990aa35d2aa8b64d9c9780f875a61c5.webp )

这样就可以精简掉调用栈，只显示我们关心的部分。

把 skipFiles 置空之后，所有代码就都展示出来了：

![](./images/32894e7214e42e71aebbcef5ee4f68d1.webp )

再来测试下，我们添加这样两个文件：

![](./images/6e9ee6bb15ba4bb6f39b4545a0885837.webp )

![](./images/19d15603b18a4f824e18956fb5321db1.webp )

在 add 里打了个断点，然后调试方式启动：

![](./images/8c0672742a0d5d22707cee2a03d49068.webp )

调用栈是这样的：

![](./images/accbfc1693060c2f28933e96e2f79085.webp )

如果你把 index 添加到 skipFiles 里：

![](./images/ac4f08259970e81b5f372cdcbf057625.webp )

那调用栈就是这样了：

![](./images/097ddec279df81e7c7e144e6e8e952e5.webp )

index.js 也被加到 skipFiles 里折叠起来了。

### stopOnEntry

这个是在首行断住，和 node --inspect-brk 的效果一样，在 chrome 调试时也有同样的配置：

![](./images/d8375704c1ed6a67c1e4a3aeec476199.webp )

## console

默认 debug 模式下，打印的日志是在 console 的，而不是 terminal。而 console 里是不支持彩色的：

![](./images/0391bddd106e264d5f8272f90219d7ff.webp )

这个可以通过 console 配置设置，有三个选项：

![](./images/d6dd28840ff41df0caa38d6b47a2b384.webp )

internalConsole 就是内置的 debug console 面板，默认是这个。

internalTerminal 是内置的 terminal 面板，切换成这个就是彩色了：

![](./images/807a9455db63e468190b17b6b886620a.webp )

externalTerminal 会打开系统的 terminal 来展示日志信息：

![](./images/088967b30e5fdd89bca8522225de5ff7.webp )

一般情况下，用 internalTerminal 就好。

### autoAttachChildProcesses

node 里是支持多进程的，可以把一些脚本放在子进程来跑来提高性能，充分利用计算机的资源。

比如这样：

```javascript
const cp = require('child_process');

cp.spawnSync('node', ['./index.js'], {
    stdio: 'inherit'
});
```

他就是把 index.js 放到子进程来跑了。

但是默认子进程的输入输出也就是 stdin（标准输入）、stdout（标准输出）不会显示在控制台，这时候可以让它继承父进程的 stdin、stdout 就可以了。

![](./images/00f6816d98e226382aff7ab9c73d5576.webp )

这个输入输出当然也可以定向到别的地方。记得前面我们指定过 console 的输出位置么？

![](./images/6712250d902c3f14b4f52ac0b7ab1df2.webp )

这个就是输入输出流 stdin、stdout 的重定向。

当然，这不是我们的重点，我们目的是为了能调试子进程的代码。

index.js 是这样的：

```javascript
const add = require('./add');

console.log(add(1, 2));
```

add.js 是这样：
```javascript
module.exports = function(a, b) {
    return a + b;
}
```

我们在 add.js 里打个断点：

![](./images/0a104b3386eff5a98de3ac53716d33b3.webp )

它是在子进程里的断点，但是跑调试你会发现能断住：

![](./images/32a24de996ec7c8a834e9c1eaf1b7db5.webp )

这是因为 autoAttachChildProcesses 的默认值是 true。

调试模式启动的时候，主进程会有调试端口，子进程也会有调试端口，而 autoAttachChildProcess 就是自动连接上子进程的 ws 调试服务的端口。

![](./images/8cdc2aa4d9260ec469df87723539c310.webp )

调用栈这里也可以看到是两级的结构，这就是 attch 到了子进程的调试服务。

如果你把 autoAttachChildProcesses 设置为 false，就会发现在子进程打的断点不会生效了。

### cwd

cwd 很容易理解就是 current work directory，当前工作目录。

也就是指定 runtime 在哪个目录运行，默认是项目根目录 workspaceFolder

比如在调试 npm scripts 的时候，指定了 cwd 就是在 cwd 下执行 npm run xxx 了：

![](./images/ebc2eee6108b516fca0b20a0a084287e.webp )

### env

node 程序很多情况下是需要取一些环境变量的，那我们要手动设置了环境变量再跑调试么？

不用，有对应的配置，也就是 env。

比如这样：

![](./images/9cb645210c432c5ffc39bade6c9730ad.webp )

这样在调试的 node 程序里就可以取到这些环境变量：

![](./images/6362a4a4f5af02b6e1a5022a412678b6.webp )

如果你有一个 envFile 来保存环境变量的话，也可以通过 envFile 的方式：

![](./images/02830715a3a4515d225dadc278c6804e.webp )

.env 内容如下：

![](./images/38c86c3109e3bbb25322fd9facce81ca.webp )

在 node 代码里可以取到对应的环境变量：

![](./images/3597cf088b757b4fe15f6bbc2a87934a.webp )

### presentation

当调试配置多了以后，就会比较乱，那能不能做一些配置的分组还有排序呢？

VSCode Debugger 是支持的。

比如这样三个调试配置：

![](./images/7f74badd2aa22ed93664e23d4ae89032.webp )

我们想把调试 chrome 的放一组，调试 node 的放一组，就可以这样写：

![](./images/ccf9a2b66d74376f2ccd4df1781890cb.webp )

![](./images/0669198c8be8645aea1808402633f30a.webp )

效果就是这样的：

大型项目里调试配置会很多，比如 VSCode，它就有很多调试配置，并用 presentation 做了分组：

![](./images/4d84eec82a585f61f5e796081b04496c.webp )

## 总结

这节我们过了一遍 VSCode Node Debugger 的调试配置：

- restart: attatch 的时候可以指定尝试重连的次数和时间间隔
- processId：除了可以通过网络端口，还可以通过进程 id 的方式 attach 到某个进程的调试服务
- program：调试的 node 代码路径，可以通过 args 传参
- runtimeExecutable：指定跑代码用的 runtime，默认是 node，也可以换成 ts-node、npm、pnpm 等，但要求这些命令在 PATH 环境变量里
- skipFiles：折叠某些路径，不显示在调用栈里，比如 node 内部的一些代码
- stopOnEntry：在首行断住，和 --inspect-brk 一样的效果
- autoAttachChildProcesses：自动 attch 到子进程的调试服务
- console：指定日志输出的位置，是内置的 console、terminal，还是外部的 terminal
- cwd：跑 runtime 的目录
- env：指定环境变量
- presentation：对多个调试配置做分组和排序

理解了这些调试配置，就可以愉快的调试 node 代码了。