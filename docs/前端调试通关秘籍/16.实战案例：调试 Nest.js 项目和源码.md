# 16.实战案例：调试 Nest.js 项目和源码

Nest.js 是当下最流行的 Node.js 服务端框架，它建立在 Express 之上，实现了 IOC 的架构模式，并且对很多方案都有集成，比如 websocket、graphql 等。

当然，这节不是讲 Nest.js 的原理，而是讲如何调试 Nest.js 的项目，如何调试 Nest.js 的源码。

## 调试 Nest.js 项目

Nest.js 提供了快速创建项目的命令行工具 @nest/cli，首先全局安装它：

```
npm i -g @nestjs/cli
```

然后用 nest new nest-test 快速创建一个 nest 的项目。

![](./images/60e650b1f68a64ad7dcfb7aa3c4296ae.webp )

进入项目目录，执行 npm run start 就会启动服务：

![](./images/30798cd2346b05cf11f9b9e08425f28e.webp )

然后浏览器访问 http://localhost:3000 ，可以看到 Hello World，说明服务启动成功了。

![](./images/bc86968f60256ecbb536566bb668e973.webp )

然后我们创建一个 node 调试配置，指定 npm 为 runtime：

![](./images/a4288e0b0de9055e605e1e0cb5f02d7f.webp )

这里 console 要设置为 integratedTerminal，这样日志会输出在 terminal，就和我们手动执行 npm run start 是一样的。

不然，日志会输出在 debug console。颜色啥的都不一样：

![](./images/2f95438fac075f40a8e7a7068b431d44.webp )

点击 Debug 启动：

![](./images/bf669c832242a9cde4c4601404bb719e.webp )

注意，用 deubg 方式跑之前要把之前起的服务关掉，不然端口会被占用。

或者也可以用这样的方式杀死占用哪个端口的进程：

![](./images/eac043fd81313f49c87caa3ad85ca6d2.webp )

在 controller 打个断点：

![](./images/962e14805fdb56389dc249551df1774d.webp )

然后浏览器重新访问 http://localhost:3000

这时候代码就会在断点处断住：

![](./images/fe81bf4e278b43d606ccdb53c40a56f8.webp )

这样就可以愉快的调试 Nest.js 项目了。

接下来我们再来调试下 Nest.js 源码。

## 调试 Nest.js 源码

其实调用栈里，我们的代码之前的部分，就是 Nest.js 框架的代码：

![](./images/e534b618043e0f0cd7eeec60d8aecf0f.webp )

但是这明显是编译后的代码：

![](./images/a432b3360eaad1335bd6e43f36e0602a.webp )

而我们是想调试 Nest 的 ts 源码的，这就需要用到 sourcemap 了。

从 npm registry 下载的包是没有 sourcemap 的代码，想要 sourcemap，需要自己 build 源码。

把 Nest 项目下载下来，并安装依赖（加个 --depth=1 是下载单 commit，--single-branch 是下载单个分支，这样速度会快很多）：

```
git clone --depth=1 --single-branch https://github.com/nestjs/nest
```
执行 npm run build，它会用 tsc 编译代码：

![](./images/439222906ca9fba2d0771b85f2236cf8.webp )

并且在 build 命令执行完之后会自动执行 postbuild：

![](./images/ba075fdeab24ed090560b32468c9b58c.webp )

它做的事情就是把编译后的文件移动到 node_modules/@nestjs 目录下：

![](./images/c93badbc3cd9c8cb04fe9bb03912cbdb.webp )

执行 npm run build，你就会在 node_modules/@nestjs 下看到这样的代码：

![](./images/c55fae1b5f0d2a829fdc1c11789875a1.webp )

只包含了 js 和 ts，没有 sourcemap：

![](./images/413b6c98100a26e4e52fbbd92d37715f.webp )

生成 sourcemap 需要改下 tsc 编译配置，也就是 packages/tsconfig.build.json 文件：

![](./images/381e03beaf46e5f994e46c0f1e839168.webp )

设置 sourceMap 为 true 也就是生成 sourcemap，但默认的 sourcemap 里不包含内联的源码，也就是 sourcesContent 部分，需要设置 inlineSources 来包含。

再次执行 npm run build，就会生成带有 sourcemap 的代码：

![](./images/7ba75b45f4da55fc34bc9b879b3d0a99.webp )

并且 sourcemap 是内联了源码的：

![](./images/6da69b4d5ed6a04c441172fd618989ba.webp )

然后我们跑一下 Nest 的项目，直接跑 samples 目录下的项目即可，这是 Nest 内置的一些案例项目：

![](./images/0d5d62b9485557c1af5675cb67d66f6a.webp )

创建这样一个调试配置：

![](./images/40bf5cc4d9210a9851e612bbd421fdc9.webp )

```json
{
    "name": "Launch via NPM",
    "request": "launch",
    "runtimeArgs": [
        "run-script",
        "start"
    ],
    "runtimeExecutable": "npm",
    "console": "integratedTerminal",
    "cwd": "${workspaceFolder}/sample/01-cats-app/",
    "skipFiles": [
        "<node_internals>/**"
    ],
    "type": "node"
}
```
主要是要指定 cwd 为那个项目的目录，也就是在那个目录下执行 npm run start。

我们在 cats 的 controller 里打个断点：

![](./images/17ef70f79a77b94ea72537fb01b45f48.webp )

然后浏览器访问 http://localhost:3000/cats ，代码就会在断点处断住：

![](./images/6ecb901445d107a95724bbf014e6d7eb.webp )

但是现在调用栈中的依然不是源码：

![](./images/03570e21e9f4b81c17d3f089d17e5da8.webp )

这是为什么呢？

这是因为这样一个调试配置 resolveSourceMapLocations：

![](./images/61af4f21544e2f991bc0d079ed2f4470.webp )

它的默认值是排除掉了 node_modules 目录的，也就是不会查找 node_modules 下的 sourcemap。

去掉那条配置：

![](./images/f1e4424af1ad1953ffe0050e26ac8f00.webp )

再跑一下：

![](./images/5c9744cfa5274f59f86ed0ce3bffb05e.webp )

这时候 sourcemap 就生效了，可以看到调用栈中显示的就是 Nest 的 ts 源码。

这样就达到了调试 Nest 源码的目的。

只不过现在 nest 的 ts 源码是只读的：

![](./images/f3b8ed9309eeacbbf8df02fe4024ed97.webp )

这是因为 sourcemap 到的路径不对，我们可以再去改下配置，修改生成的 sourcemap 的路径：

![](./images/0d0b7de6e9240ade487d7c74260ea474.webp )

那为什么 sourcemap 到的路径不对呢？

看下 map 文件：

![](./images/bf99892d426466bb2d7c4337d82abd46.webp )

sourcemap 到的路径是 sourceRoot + sources 文件名。

我们需要设置下 sourcesRoot。

nest 的这几个目录下都有单独的 tsconfig.build.json，需要分别设置：

![](./images/26cd48121ef2820b80236b2ba2538549.webp )

比如我设置了 core 包下的 tsconfig.build.json 的 sourceRoot 为 core 包的绝对路径：

![](./images/d7b2544b63e5f32490c69c801448d678.webp )

再次 build，生成的 map 文件就是这样的：

![](./images/c7e701a792d4a252fd89f3057bb8e98b.webp )

重新跑下调试：

![](./images/e6664debbed7aecf947bc3d4892f74ba.webp )

现在的路径就对了，内容不再只读，而且点击可以直接跳到源码文件：

![](./images/e27ef1857befd909d58c29d4c2ab7b74.webp )

至此，我们就可以愉快的调试 Nest.js 源码了。

## 总结

Nest.js 是流行的 node 服务端框架，这节我们实战了下 Nest 项目的调试和源码的调试。

调试 Nest.js 项目就是用 npm 的方式启动调试配置，指定下 console 为 terminal 就可以了。

调试 Nest.js 源码的话，需要把 Nest 源码下载下来，build 出一份带有 sourcemap 版本的代码，同时还要设置 resolveSourcemapLocations 去掉排除 node_modules 的配置，然后再调试，就可以直接调试 Nest 的 ts 源码了。
