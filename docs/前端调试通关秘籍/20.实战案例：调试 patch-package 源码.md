# 20.实战案例：调试 patch-package 源码

有时候我们需要修改 node_modules 下的一些代码，但是 node_modules 不会提交到 git 仓库，改动保存不下来，怎么办呢？

这时候可以用 [patch-package](https://github.com/ds300/patch-package#readme) 这个工具。

比如我对 node_modules 下的 acorn 代码做了一些修改：

加了一个 a.js 的文件：

![](./images/00a4b54226243f8ce4477aebfb9fac17.webp )

在项目目录下执行 npx patch-package acorn 之后，就会生成这样一个目录：

![](./images/59e4d25045c0b5fb96d39d7c0566123d.webp )

在 patches 目录下的 xx.patch 文件里记录着对这个包的改动。

![](./images/cc7db3e8d6635b9da8c41f9bbefab4ce.webp )

这个 patches 目录是可以提交到 git 仓库的，然后再次把项目拉下来的时候，执行下 npx patch-package 就会应用这次改动。

![](./images/e6cb4be11afd62b1706688f1ef408996.webp )

可以把它配到 postintsll 里，每次安装完依赖自动跑。

![](./images/231fecdf714953d3e91a515ade3755a1.webp )

这样能保证每次拉取下来的代码都包含了对 node_modules 的改动。

如何使用我们学会了，那它是怎么实现的呢？

这节我们就来调试下 patch-package 的源码。

## 调试 patch-package 源码

首先把代码下载下来：

```
git clone git@github.com:ds300/patch-package.git
```

安装依赖，然后执行 npm run build，你会在 dist 目录下看到编译产物。

![](./images/04b74c0a9c54f9b08885101f3d75b600.webp )

它默认就是有 sourcemap 的，只不过是 base64 的方式内联的：

![](./images/eaacee374a6c5cb02c3b2ac42ba52f20.webp )

因为它的编译配置是这样的：

![](./images/f08286edfda86aaf71ffc8d54544cacd.webp )

接下来开始调试：

在 package.json 中可以看到 patch-package 命令的入口是 index.js：

![](./images/d330c0e317756747becca75c2d48d27e.webp )

也就是 dist/index.js 就是要调试的入口文件。

探究它的实现原理要分为两各方面，一个是 patches 文件怎么生成的，一个是 patches 文件怎么被应用的。

我们分别来看一下：

### patches 文件怎么生成的

看 patches 文件的内容就能看出来这是 git 的 diff：

![](./images/4af6dadb43cbbe40e019ed44566ba4aa.webp )

确实，patch-package 就是依赖 git diff 实现的 patches 文件生成。

生成这样的 patch 文件执行的是 patch-package xxx 命令，这里就是 node ./dist/index xxx

你可以先对 node_modules 下的某个包做下改动，然后执行 node ./dist/index xxx 来生成 patches 文件。 

然后添加这样一个调试配置：

![](./images/7a017a62464d09b35cc4913c5416d1c6.webp )

```json
{
  "name": "调试 patch-package",
  "program": "${workspaceFolder}/dist/index.js",
  "request": "launch",
  "skipFiles": [
    "<node_internals>/**"
  ],
  "console": "integratedTerminal",
  "args": [
    "acorn"
  ],
  "type": "node"
}
```

这里的 args 里填写你修改过的 node_modules 下的包名，我这里改的是 acorn 包下的代码。

看下这个命令的打印：

![](./images/7c8aade71a30a21817b74b978e99860f.webp )

我们可以通过这些打印信息搜索对应的源码来打断点，比如搜索 Created file

![](./images/f8a2822ff6a86f184cc8319bd0cf88b5.webp )

定位到了源码，打个断点，然后 Debug 启动：

![](./images/9f2a0f3ace349bfad818dd8e6bee463c.webp )

没错，这就是打印那行信息的代码。

然后我们往上看一下，你会看到这些代码：

首先 patch-package 会创建一个临时目录：

![](./images/fabade230a416719c427ceaa6de5dae9.webp )

然后在这个目录写入一个 package.json 文件，dependencies 就是命令行参数指定的包名：

![](./images/53ff9fcf8069310118834f6e3cfb140f.webp )

我们去这个目录看一下：

![](./images/d93d23d4d8eb9aa43424734d647f0249.webp )

确实，是有这样一个 package.json 的。

然后它会在这个目录下执行 yarn install 或者 npm install（patch-package 现在不支持 pnpm）：

![](./images/7c98644ba81c94301581e4eb66d406c8.webp )

![](./images/f5315d57731dc9d024212488c71b2a16.webp )

之后就进行 git 的 init、add、commit，生成一个基础的 commit。

![](./images/3f17c6566de2a80adb0152bbbcf3cf2e.webp )

然后把现在 node_modules 目录下的这个被修改过的包复制过去：

![](./images/a93e50fd91c6912c8ef1f5b285a55272.webp )

之后再 git add，然后执行 git diff，就能拿到改动的 diff：

![](./images/0632ed41ac6013236865c72253c4ada1.webp )

这不就是 patches 文件的内容么：

![](./images/a22130c2533e09536a03616efa1d86ed.webp )

然后写到 patches 目录即可

![](./images/5599b022819ac29bd17fac40c5943cae.webp )

patches 文件的生成还是挺简单的，就是在临时目录下创建了一个基础 commit，然后把新的内容复制过去，通过 git diff 生成的 patches 内容。

上面这些都是通过单步、断点调试得出的：

![](./images/294f16fba4b5661d76197d88388aae08.webp )

那应用 patches 的内容是怎么实现的呢？

## patches 如何被应用的？

我又对 acorn 目录下的文件做了些修改，生成的 patches 文件是包含了增删改的：

![](./images/19ffb48b507526920498e0a5bce83c25.webp )

![](./images/0415e3ffede149fdac00e5d5b62a1282.webp )

![](./images/99e0a7eb541b07c1cf80761309676d62.webp )

patches 文件里记录了对哪几行做了新增，哪几行做了删除，哪几行做了修改。

如果人工应用这个 patches 文件的话，不就是找到对应文件的对应行数，做反向的操作就可以了么？

没错，patch-package 也是这样实现的，不过是自动进行的：

应用 patch 是执行 patch-package 命令，这里就是 node ./dist/index

所以添加一个这样的调试配置：

![](./images/eb8d45d2cf21174fa068bdaa2cca595a.webp )

```json
{
  "name": "调试 patch-package apply",
  "program": "${workspaceFolder}/dist/index.js",
  "request": "launch",
  "skipFiles": [
    "<node_internals>/**"
  ],
  "console": "integratedTerminal",
  "type": "node"
}
```

同样，搜索下这行打印信息：

![](./images/11fee780d9b26088306359a19f749aa4.webp )

打个断点：

![](./images/bee4f6ce917a3444d7a92aa0a802f561.webp )

debug 跑起来，

然后 step into 这个函数：

![](./images/5a59eb584c76bb6abfc518950c60d26b.webp )

单步执行到这行代码：

![](./images/92b62448a9c6d44fdc4fbb65e6982771.webp )

再 step into 进入函数内部：

![](./images/e3b176a2f3a915394232e5db0998de46.webp )

你会发现读取 patch 文件的代码，进入那个 readPatch 内部：

会发现它读取 patches 文件之后会进行 parse：

![](./images/16c4a0e2d474a60b163206d88cec62e5.webp )

这个 parse 的实现就是对每一行的字符串做判断，进行不同的处理：

![](./images/1a9933cacffd63a744639b4ee7064a7f.webp )

最终能得到一个包含 diff 信息的对象，包含了对什么文件的哪些行做了什么修改：

![](./images/4a71bc1dea41de43aa656035f0fe5698.webp )

之后在 executeEffects 函数里对 patch 信息做了相应的处理：

![](./images/23bd6e17697df657bc52ed764dbd19e2.webp )

也就是根据不同的类型做了不同的操作：

![](./images/3c41746427f42fcfd76b01de9746f0e0.webp )

这样就把 patches 文件里的改动应用到了 node_modules 下的包里。

至此，我们通过调试 patch-package 源码理清了它的实现原理。

前面说 patch-pakckage 不支持 pnpm，其实 pnpm 内置 [patch](https://pnpm.io/cli/patch)、patch-commit 命令，作用和这个 patch-package 包一样。

![](./images/f28a6bf14dbe5851737929dae8c65cab.webp )

## 总结

当我们需要对 node_modules 下的代码做改动的时候，可以通过 patch-package xxx 生成 patches 文件，它可以被提交到 git 仓库，然后再拉下来的代码就可以通过 patch-package 来应用改动。

实现原理要分为两部分来看：

patches 文件的生成是在临时目录生成 package.json，下载依赖，生成一个 commit，然后把改动的代码复制过去，两者做 gif diff，就可以生成 patches 文件。

patches 文件的应用则是 patch-package 自己实现了它的 parse，拿到对什么文件的哪些行做什么修改的信息，之后根据不同做类型做不同的文件操作就可以了。

如果是 pnpm，那 patch-package 不支持，这时候用内置的 pnpm patch 命令就好了。

当然，更重要的是我们是通过自己调试源码来得出这些信息的，当你会调试源码之后，就可以自己去深入很多技术了。这也是为什么会调试源码是对工程师进阶很重要。
