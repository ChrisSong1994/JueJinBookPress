# 27.实战案例：调试 ElementUI 组件源码

上节写了怎么调试 antd 的源码，但很多小伙伴是写 Vue 的，可能平时用的是 Element UI 的组件库，所以这节就来讲下怎么调试 Element UI 的源码。

首先，我们用 Vue CLI（用 vue cli5） 创建一个 vue2 的项目：

```
yarn global add @vue/cli

vue create element-vue-test
```

创建成功后，进入到项目目录

![](./images/e9a2c831765e4d10d6dfeccb811dae02.webp )

安装 element ui 的库，并在入口引入：

![](./images/9d45932e97316814b58ad7d8cbe9990a.webp )

然后在 App.vue 里用一下 button 组件

![](./images/c83bf03756e812b8a1c286f8e387735c.webp )

之后 yarn run serve 把开发服务跑起来，就可以看到这样的页面：

![](./images/89f39d38f307dd0ac15a35f46b4b70a4.webp )

Element UI 的组件正确的显示了。

接下来调试 button 组件的源码，那问题来了，我怎么知道在哪里打断点呢？

我们可以知道的是，这个 button 会处理点击事件，但是却不知道事件处理函数的代码在什么地方。

这种情况可以加一个事件断点：

![](./images/4c5fef19f167dbcb8c660ff22fbb63d4.webp )

在 sources 面板的 Event Listener Breakponts 里勾选 Mouse 的 click 事件，也就是在所有 click 事件的处理函数处断住。

然后你再点下那个按钮试试看：

![](./images/245243d6e275363326af17c907cb7bec.webp )

你会发现它在事件处理函数处断住了。

当你知道这个组件处理了什么事件，但却不知道事件处理函数在哪的时候就可以用事件断点。

当然，这个事件处理函数并不是组件里的，因为 Vue 内部会先做一些处理，然后再交给组件处理。

所以，我们要先走到组件的事件处理函数：

![](./images/1c84539ea79bf2ecee370a9887b1afd6.webp )

单步执行、再进入函数内部，再单步执行、再进入函数内部，代码就会走到组件的事件处理函数：

![](./images/02c578f5cb5c1b729eb591c171b0ed8c.webp )

methods、computed、props，这明显是源码里的了。但你再往上走两步，会发现又不是最初的源码：

![](./images/4e7a2a5e80ec82b9b83ca4a10de41de6.webp )

template 变成了 render 函数，而且还有其他组件的代码，这明显是被编译打包之后的代码。

从文件名也可以看出来：

![](./images/f1ae27cf02a64e6444d076caa9222119.webp )

这是一个把所有组件代码编译后打包到一起的文件。

这样虽然也能调试，但肯定是不爽的，能不能直接调试组件最初的源码呢？就是带 template 的单文件组件那种？

是可以的，这就要用到 sourcemap 了。

sourcemap 是在编译过程中产生的：

![](./images/95643f924ecc14244166a6d8ba79b106.webp )

里面记录了目标代码和源代码的映射关系，调试的时候可以通过它映射回源码：

![](./images/ace47d42f49a50c5b8072b74998ef224.webp )

但是你去 node_modules 下看看，会发现没有这个文件的 sourcemap：

![](./images/ae45a2717a9b1e802b8c380c01170524.webp )

那怎么生成它的 sourcemap 呢？

这就要从源码重新编译了。

我们从 github 把它的源码下载下来：

```
git clone --depth=1 --single-branch git@github.com:ElemeFE/element.git
```

--depth=1 是只下载单个 commit，--single-branch 是下载单个 branch，这样下载速度能快几十倍，是一个加速小技巧。

进入 element 目录，安装依赖，你会遇到一个前端经常头疼的问题，node-sass 安装报错了：

![](./images/22ee8d13205a515a42d98d782e6badbf.webp )

这个问题的解决方案就是把 node 版本切换到 node-sass 版本对应的那个。

package.json 中可以看到 node-sass 是 4.11.0

![](./images/d52bf9da8fcab8171f806695feaaccc7.webp )

打开 node-sass 的 github 首页：

你会看到这样一个版本对应关系表：

![](./images/2611900fc0d5ed23819d74ef0fc0bce6.webp )

4.11 对应 node11，那就把 node 切换到 11 就可以了。

然后再次 yarn 安装依赖就能成功了。

之后开始编译，在 npm scripts 中可以找到 dist 命令，这就是构建源码用的：

![](./images/c30436e0dd7a496bee16958612282b43.webp )

但是我们只需要 element-ui.common.js 这个文件：

![](./images/6b137785077e6c91ea716a066c283c6d.webp )

其实只需要执行其中的一部分脚本，也就是这个：

![](./images/a3c0134db84fca33868c4620da3b5036.webp )

所以在项目下执行 npx webpack --config build/webpack.common.js 即可：

![](./images/615d3603f1cb470e98e0f118476c1b79.webp )

然后在 lib 下就可以看到构建产物：

![](./images/12f9eea00636ad4493b7488e29d20a36.webp )

但我们的目标是生成带有 source-map 的代码，所以要改下配置：

修改 build/webpack.common.js，配置 devtool 为 cheap-module-source-map：

![](./images/177c6221e0ba44d2c0b578d1de7e1538.webp )

source-map 是生成 sourcemap 并关联，也就是这样：

![](./images/d690e50ad4f4b025a00fdbf3e52318ce.webp )

module 是把中间 loader 产生的 sourcemap 也给合并到最终的 sourcemap 里，这样才能直接映射到源码。

cheap 是加快编译速度用的，只保留行的映射信息。

改完配置后再次 npx webpack --config build/webpack.common.js，就可以看到带有 sourcemap 的产物了：

![](./images/0a89244ba9b41a06de2b964d54f3987f.webp )

把这俩文件复制到测试项目的 node_modules/element-ui 下覆盖下之前的：

![](./images/e6669d60d9597e2c37641bf33964ebc0.webp )

devtool 设置为 source-map:

![](./images/a9be088f34a93cb75c8ceb3c147688da.webp )

之后清掉 node_modules/.cache 下的缓存，重新跑 dev server：

![](./images/721a94579ab63c8cb8dbd9dfdb46f062.webp )

这时会报错提示你 node 版本太低了，你需要再把 node 版本换回来：

![](./images/b5d589675c4333e0773b9bf3bc348763.webp )

跑起开发服务之后，再次用之前的方式调试 button 组件的源码：

![](./images/a856a2c2b49a5673f16b87b69f160080.webp )

你会发现现在的组件代码是带 template 语法的单文件组件的代码了！

![](./images/a046aced35e5f20c4d08a3607950d5db.webp )

这就是 sourcemap 的作用。

之后你会可以在这个组件里打断点然后调试。

有的同学可能会问，通过事件断点进入组件内部，这样有点麻烦，有没有更简单的方式？而且 button 组件有点击事件，但有的组件没有呀，这些组件该怎么调试呢？

确实，有了 sourcemap 之后就有更简单的调试方式了。

你可以在 sources 左边看到 ELEMENT 目录下有很多 vue 文件，这其实就是 Chrome DevTools 解析 sourcemap 之后列在这里的：

![](./images/752ec46dd17340c279ea5c60bcbd2544.webp )

你可以直接在里面打断点调试。

比如我们加一个 tabs 组件：

![](./images/1b4e6103b2ed4a161ee8ca39d3bbe30e.webp )

把前面添加的那个事件断点去掉，在代码里手动打一个断点：

![](./images/7b2eed2fff467ab206be002e6cb287dc.webp )

然后你就会发现，这样就可以调试 Element UI 组件源码了！

![](./images/21a5199547e8c78dad11513ddcc80f6c.webp )

当然，有的组件找不到的时候，还是可以通过事件断点的方式来进入组件内部。

我们是通过 Chrome DevTools 调试的，其实用 VSCode Debugger 来调试它也是一样的，在 Chrome DevTools 里打的断点，在 VSCode Debugger 里同样会断住。

## 总结

这节我们调试了 Element UI 的源码。

定位到组件的代码，是通过事件断点的方式，因为我们知道它触发了什么事件，但却不知道事件处理函数在哪。

但是组件的代码是被编译打包过的，不是最初的源码。

为了调试最初的源码，我们下载了 Element UI 的代码，build 出了一份带有 sourcemap 的代码。

覆盖项目 node_modules 下的代码，重新跑 dev server，这时候就可以直接调试组件源码了。

有了 sourcemap 之后，Chrome DevTools 会直接把 vue 文件列在 sources 里，我们可以找到对应的 vue 文件来打断点，就不用通过事件断点来找了。

能够调试 Element UI 源码之后，想知道组件内部都有哪些逻辑的话，就可以直接在源码断点调试了，就很香。
