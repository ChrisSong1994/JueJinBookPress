项目写完了，本地跑没啥问题，我们最终是要把它部署到服务器上，跑起来。

我们会用到 mysql、redis、nginx，它们是这样的关系：

![](./images/fe3aa0c61f374ccaa7f0d99750fc82e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

前端代码由 nginx 托管，处理静态请求。

并且后端服务也会经过 nginx 做反向代理，这样可以做多个 Nest 服务的负载均衡。

Nginx、Mysql、Redis、Nest 服务等都是通过 docker 来跑。

当然，不用一个个的跑，可以通过 Docker Compose 把它们组合成一个整体，一起跑。

开发完之后，本地把代码 push 到 github、gitlab 等代码仓库。

之后服务器上把代码 pull 下来，然后用 docker compose 跑就行。

![](./images/6f000e3d6eb7419390b031e7dfbcadf1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

有了 docker，根本不用考虑 mysql、redis、node 等在 linux 下怎么装，直接跑 docker 镜像就行。

是不是再次感受到了 docker 的好处？

此外，还有一点要注意，线上不能开启 typeorm 的 synchronize，这样代码一改就同步修改了表结构，容易导致数据丢失。

线上会用 migration 迁移来做。

详细的 migration 介绍看[这节](https://juejin.cn/book/7226988578700525605/section/7336184436872085531)。

我们一步步来做，首先，在本地用 docker compose 跑一下:

在后端项目的根目录添加 docker-compose.yml 文件：

```yml
version: '3.8'
services:
  nest-app:
    build:
      context: ./
      dockerfile: ./Dockerfile
    depends_on:
      - mysql-container
      - redis-container
    ports:
      - 3005:3005
    networks:
      - common-network
  mysql-container:
    image: mysql
    volumes:
      - /Users/guang/mysql-data:/var/lib/mysql
    environment:
      MYSQL_DATABASE: meeting_room_booking_system
      MYSQL_ROOT_PASSWORD: guang
    networks:
      - common-network
  redis-container:
    image: redis
    volumes:
      - /Users/guang/redis-data:/data
    networks:
      - common-network
networks:
  common-network:
    driver: bridge
```
有 3 个 docker 容器，nest-app、mysql-container、redis-container

nest-app 是通过 Dockerfile 构建出来的，暴露 3005 端口。

nest-app 依赖 redis-container 和 mysql-container

redis-container 指定挂载的 volume 数据卷，以及 MYSQL_DATABASE（自动创建的 database） 和 MYSQL_ROOT_PASSWORD（root 用户密码） 的环境变量

mysql-container 指定挂载的 volume 数据卷

然后这是三个容器放到同一个桥接网络里。

在根目录添加 Dockerfile：

```docker
FROM node:18.0-alpine3.14 as build-stage

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18.0-alpine3.14 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install --production

EXPOSE 3005

CMD ["node", "/app/main.js"]
```
Nest 如何写 Dockerfile [前面](https://juejin.cn/book/7226988578700525605/section/7236247409871814714)也讲过。

就是用多阶段构建，第一个镜像先复制 package.json，然后安装依赖。

之后执行 npm run build 生成 dist 目录。

接下来第二个镜像复制第一个镜像的 dist 目录和 package.json，然后执行  npm install 并且用 node 跑起来。

改下 .env 文件：

![](./images/ac5e45d0698c4c4fa875e3f1daaaaf82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

把 localhost 改为 redis-container 和 mysql-container。

还要改一个地方：

![](./images/ae1e38d5fd2f4d53aa30507d641d3118~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

加载配置文件的目录要改成拼接 __dirname 和 .env 的路径。

```javascript
ConfigModule.forRoot({
  isGlobal: true,
  envFilePath: path.join(__dirname, '.env')
}),
```
因为 build 出来的代码没有 src 目录，是直接放在 dist 下的：

![](./images/e83d5c264db24c80bf53002843c71a9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

加一下 .dockerignore，也就是不会被复制到容器内的文件

```ignore
node_modules/
.vscode/
.git/
```

接下来把它跑起来（最好把本地的 mysql 和 redis 容器停掉再跑）：

```
docker compose up
```

它会首先根据 Dockerfile 生成 nest-app 的镜像：

![](./images/e31ab5319ee243cbbd2ddd7fe9d0b86b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

然后分别跑 mysql-container 和 redis-container 容器：

![](./images/383d1f3ed26c44ae9cb09f3b152302eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

最后可以看到 nest-app 也跑起来了：

![](./images/06405d52491744fdb36f96fd75c65339~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

访问下接口：

![](./images/24df2ea25df04a888e7a217764b0fadb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/c1879e54c72049c68ab1ac091ef2f6ee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

可以看到，接口也是没问题的。

如果你改了 Dockerfile 或者 docker-compose.yml 想重新跑的话，需要先把之前的镜像和容器删掉再跑：

```
docker-compose down --rmi all
```
![](./images/1acfc6d3c6f9489486a71ef28a7dbf75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

接下来把本地代码 push 到 gitlab 或者 github：

![](./images/0a2d0a7ac80e4a05806d7f54c133d3b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

然后在服务器上把它拉下来跑下 docker compose up 就行了。

我们买个服务器：

![](./images/5bfd9524b6584e9e930b1fd144979915~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/5ce783f7dfdc4399b16efe446e60408c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/58b39e04ada347caa3cc1f520a41bfba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

我选的是 1 核、1G 的买了一周，大家可以根据自己的需要买。

注意要勾选公网 ipv4 地址，不然访问不了公网。

之后进入控制台就可以看到这台服务器了：

![](./images/22358f10142542e6b251b89205552e7e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

点击远程连接：

![](./images/5b9dafecb31a4a848f70ebcac6af1d23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

点立即登录。

我们用 ssh 密钥的方式登录，这里需要一个密钥文件：

![](./images/ce5b3659cb96422eb888a39c5b9a3cfe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

在这里创建：

![](./images/0d5f5c552bbe4ce79ebc3598bdd5e196~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

创建完会自动下载密钥文件：

![](./images/e8b2734a2081432db9660e4cd8fb99bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

然后点击绑定密钥对，也就是用这个密钥来登录的服务器：

![](./images/8fe54fb3206f4143855c2ab5b0ae32b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

这一步会重启服务器。

然后再次远程连接，就可以用这个密钥文件来登录了:

![](./images/ed6a8b042737473c9000caf9c232163e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

我们需要安装 git 和 docker，用 git 下载代码，然后用 docker compose 来跑代码。

安装 git：

```
yum install git -y
```
![](./images/df714fa30eb94418a6df4c4816e6fd71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/cbd0e48ddcad43da93c00d43d8ecf67b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

把 github 的代码下下来：

```
git clone 你自己的git仓库
```

![](./images/0d69ef2e1c264972b439e5301e4b111c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

进入项目目录，跑下 docker compose 就行：

![](./images/74e559eee59e47899a64601c65743ce1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

和我们本地跑一样。

我们安装下 docker：

怎么安装直接看[阿里云的文档](https://help.aliyun.com/zh/ecs/use-cases/deploy-and-use-docker-on-alibaba-cloud-linux-2-instances)就行。

![](./images/e4224141942048e88d1634528300844c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/c37257d8e8bb4f7c811d9bcdf93532e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/1b70cec7e87049fd8080cdd3baf045f5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

docker 安装好了，设置下开机启动，也是复制文档的命令就行：

![](./images/ffcf6b83e4794250b045f2f01a14c566~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/f9d595720bbc420fb373fcc4b46d1da4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

然后安装 docker compose，同样是直接复制：

![](./images/11ca9f018b434f96a44bf8d77f2ff86f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/22373952a3774c70a4a34fbcf79b1325~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

docker compose 安装好了，就把服务跑起来：

```
docker-compose up
```
![](./images/a1f07127d1164798ac9f145dea870ea8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

会先 pull mysql 和 redis 的镜像，然后 build nest 的镜像。

之后就把服务跑起来了：

![](./images/36d84091c7f54b83a8bf0741d151d0f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

过程中可以看到，会自动创建一系列的 table：

![](./images/9f0b84e6595d45f086b2245421fd8ec7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

因为我们现在还没关掉 synchronize。

因为我们服务跑在 3005 端口，需要在安全组添加一下这个端口：

![](./images/0d95ea9897ce4e5db0a7cc5c85a071be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/a620e94d576e47c691d95d4af7507788~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

然后就可以用公网 ip 访问了：

![](./images/4a55fe2e53e24b4a8915df102fc306fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/b432875abd474bf28681d98370a4a80e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

![](./images/0e3f9b20997f417a849ebe110e9ba6bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image.png)

当然现在的初始化数据还没加，并且创建表也不是用的 migration，用 synchronize 不够安全，这些我们下节再继续搞。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们完成了阿里云的部署。

写了 docker-compose.yml 和 Nest 应用的 Dockerfile，在本地用 docker compose 跑没问题。

然后服务器上也是用同样的方式跑。

买了一台阿里云服务器，安装 git 来下载项目代码，然后安装 docker compose 把服务跑起来就行了。

部署成功之后，我们的服务就可以在世界各地访问了。
